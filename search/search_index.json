{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Tentang Nama : Robby Alamsyah NIM : 190411100046 Dosen Pembimbing : MULA'AB, S.Si., M.Kom Apa itu Komputasi Numerik? Komputasi numerik adalah cabang matematika yang berkaitan dengan metode, biasanya iteratif, untuk mendapatkan solusi untuk masalah dengan cara komputer.","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#tentang","text":"Nama : Robby Alamsyah NIM : 190411100046 Dosen Pembimbing : MULA'AB, S.Si., M.Kom","title":"Tentang"},{"location":"#apa-itu-komputasi-numerik","text":"Komputasi numerik adalah cabang matematika yang berkaitan dengan metode, biasanya iteratif, untuk mendapatkan solusi untuk masalah dengan cara komputer.","title":"Apa itu Komputasi Numerik?"},{"location":"Aljabar%20Linear/01_Pengantar/","text":"Pengantar Definisi Aljabar Linear Aljabar Linear adalah cabang matematika yang berkaitan dengan struktur matematika yang ditutup di bawah operasi penambahan dan perkalian skalar dan yang mencakup teori sistem persamaan linear, matriks, determinan, ruang vektor, dan transformasi linier. Referensi : Aljabar Linear - Wikipedia Menara Ilmu Aljabar Linear - UGM Aljabar Linear Elementer : Sistem Persamaan Linear - Youtube Bermatematika.com Aljabar Linier Bab 3 sistem persamaan linier - SlideShare","title":"Pengantar"},{"location":"Aljabar%20Linear/01_Pengantar/#pengantar","text":"","title":"Pengantar"},{"location":"Aljabar%20Linear/01_Pengantar/#definisi-aljabar-linear","text":"Aljabar Linear adalah cabang matematika yang berkaitan dengan struktur matematika yang ditutup di bawah operasi penambahan dan perkalian skalar dan yang mencakup teori sistem persamaan linear, matriks, determinan, ruang vektor, dan transformasi linier. Referensi : Aljabar Linear - Wikipedia Menara Ilmu Aljabar Linear - UGM Aljabar Linear Elementer : Sistem Persamaan Linear - Youtube Bermatematika.com Aljabar Linier Bab 3 sistem persamaan linier - SlideShare","title":"Definisi Aljabar Linear"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/","text":"Aljabar Linear dengan SciPy Package Python utama untuk aljabar linear adalah scipy.linalg yang merupakan subpackage SciPy yang dibangun di NumPy . Mari kita impor kedua package yang akan kita gunakan: import numpy as np import scipy.linalg as la NumPy Arrays Mari kita mulai dengan ulasan singkat tentang array pada NumPy. Kita dapat membayangkan array 1D sebagai daftar angka. Kita bisa membayangkan array 2D sebagai matriks. Dan kita bisa membayangkan array 3D sebagai kubus angka. Saat kita memilih baris atau kolom dari array 2D, hasilnya adalah array 1D (disebut potongan). Ini berbeda dengan MATLAB di mana ketika Anda memilih kolom dari matriks, kolom dikembalikan sebagai vektor kolom yang merupakan matriks MATLAB 2D. Ini bisa sedikit membingungkan dan jadi kita perlu melacak bentuk, ukuran, dan dimensi array kita. Atribut Array Buat array NumPy 1D (satu dimensi) dan verifikasi dimensi, bentuk, dan ukurannya. a = np.array([1,3,-2,1]) print(a) # Output: [ 1 3 -2 1] Verifikasi jumlah dimensi: a.ndim # Output: 1 Verifikasi bentuk array: a.shape # Output: (4,) Bentuk array dikembalikan sebagai tuple. Output dalam sel di atas adalah tuple dengan panjang 1. Dan kita memverifikasi ukuran array (yaitu jumlah total entri dalam array): a.size # Output: 4 Selanjutnya membuat array NumPy 2D (dua dimensi) (yaitu matriks): M = np.array([[1,2],[3,7],[-1,5]]) print(M) # Output: # [[ 1 2] # [ 3 7] # [-1 5]] Verifikasi jumlah dimensi: M.ndim # Output: 2 Verifikasi bentuk array: M.shape # Output: (3, 2) Terakhir, verifikasi jumlah total entri dalam array: M.size # Output: 6 Pilih baris atau kolom dari array NumPy 2D dan kami mendapatkan array 1D: col = M[:,1] print(col) # Output: [2 7 5] Verifikasi jumlah dimensi potongan: col.ndim # Output: 1 Verifikasi bentuk dan ukuran potongan: col.shape # Output: (3,) col.size # Output: 3 Saat kita memilih baris kolom dari array NumPy 2D, hasilnya adalah array NumPy 1D. Namun, kami mungkin ingin memilih kolom sebagai vektor kolom 2D. Ini mengharuskan kita untuk menggunakan metode reshape . Misalnya, buat vektor kolom 2D dari potongan 1D yang dipilih dari matriks M di atas: print(col) # Output: [2 7 5] column = np.array([2,7,5]).reshape(3,1) print(column) # Output: # [[2] # [7] # [5]] Verifikasi dimensi, bentuk, dan ukuran array: print('Dimensions:', column.ndim) print('Shape:', column.shape) print('Size:', column.size) # Output: # Dimensions: 2 # Shape: (3, 1) # Size: 3 Variabel col dan column adalah berbagai jenis objek meskipun mereka memiliki data yang \"sama\". print(col) # Output: [2 7 5] print('Dimensions:', column.ndim) print('Shape:', column.shape) print('Size:', column.size) # Output: # Dimensions: 2 # Shape: (3, 1) # Size: 3 Operasi dan Fungsi Matriks Operasi Aritmatika Ingat bahwa operasi array aritmatika +, -, /, * dan ** dilakukan secara elementwise pada array NumPy. Mari kita membuat array NumPy dan melakukan beberapa komputasi: M = np.array([[3,4],[-1,5]]) print(M) # Output: # [[ 3 4] # [-1 5]] M * M # Output: # array([[ 9, 16], # [ 1, 25]]) Perkalian Matriks Kami menggunakan operator @ untuk melakukan perkalian matriks dengan array NumPy: M @ M # Output: # array([[ 5, 32], # [-8, 21]]) Mari kita menghitung \\(2I + 3A - AB\\) untuk \\[ A = \\begin{bmatrix} 1 & 3 \\\\ -1 & 7 \\end{bmatrix} \\ \\ \\ \\ B = \\begin{bmatrix} 5 & 2 \\\\ 1 & 2 \\end{bmatrix} \\] dan \\(I\\) adalah matriks identitas ukuran 2: A = np.array([[1,3],[-1,7]]) print(A) # Output: # [[ 1 3] # [-1 7]] B = np.array([[5,2],[1,2]]) print(B) # Output: # [[5 2] # [1 2]] I = np.eye(2) print(I) # Output: # [[1. 0.] # [0. 1.]] 2*I + 3*A - A@B # Output: # array([[-3., 1.], # [-5., 11.]]) Matrix Powers Tidak ada simbol untuk matrix power dan jadi kita harus mengimpor fungsi matrix_power dari subpackage numpy.linalg. from numpy.linalg import matrix_power as mpow M = np.array([[3,4],[-1,5]]) print(M) # Output: # [[ 3 4] # [-1 5]] mpow(M,5) # Output: # array([[-1525, 3236], # [ -809, 93]]) Bandingkan dengan operator perkalian matriks: M @ M @ M @ M @ M # Output: # array([[-1525, 3236], # [ -809, 93]]) mpow(M,3) # Output: # array([[-17, 180], # [-45, 73]]) M @ M @ M # Output: # array([[-17, 180], # [-45, 73]]) Tranpose Kita bisa mengambil transpose dengan atribut .T: print(M) # Output: # [[ 3 4] # [-1 5]] print(M.T) # Output: # [[ 3 -1] # [ 4 5]] perhatikan bahwa \\(MM^T\\) adalah matriks simetris: M @ M.T # Output: # array([[25, 17], # [17, 26]]) Inverse Kita dapat menemukan inversi menggunakan fungsi scipy.linalg.inv: A = np.array([[1,2],[3,4]]) print(A) # Output: # [[1 2] # [3 4]] la.inv(A) # Output: # array([[-2. , 1. ], # [ 1.5, -0.5]]) Trace Kita dapat menemukan trace matriks menggunakan fungsi numpy.trace: np.trace(A) # Output: 5 Determinant Kita menemukan determinan menggunakan fungsi scipy.linalg.det: A = np.array([[1,2],[3,4]]) print(A) # Output: # [[1 2] # [3 4]] la.det(A) # Output: -2.0","title":"Aljabar Linear dengan SciPy"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#aljabar-linear-dengan-scipy","text":"Package Python utama untuk aljabar linear adalah scipy.linalg yang merupakan subpackage SciPy yang dibangun di NumPy . Mari kita impor kedua package yang akan kita gunakan: import numpy as np import scipy.linalg as la","title":"Aljabar Linear dengan SciPy"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#numpy-arrays","text":"Mari kita mulai dengan ulasan singkat tentang array pada NumPy. Kita dapat membayangkan array 1D sebagai daftar angka. Kita bisa membayangkan array 2D sebagai matriks. Dan kita bisa membayangkan array 3D sebagai kubus angka. Saat kita memilih baris atau kolom dari array 2D, hasilnya adalah array 1D (disebut potongan). Ini berbeda dengan MATLAB di mana ketika Anda memilih kolom dari matriks, kolom dikembalikan sebagai vektor kolom yang merupakan matriks MATLAB 2D. Ini bisa sedikit membingungkan dan jadi kita perlu melacak bentuk, ukuran, dan dimensi array kita.","title":"NumPy Arrays"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#atribut-array","text":"Buat array NumPy 1D (satu dimensi) dan verifikasi dimensi, bentuk, dan ukurannya. a = np.array([1,3,-2,1]) print(a) # Output: [ 1 3 -2 1] Verifikasi jumlah dimensi: a.ndim # Output: 1 Verifikasi bentuk array: a.shape # Output: (4,) Bentuk array dikembalikan sebagai tuple. Output dalam sel di atas adalah tuple dengan panjang 1. Dan kita memverifikasi ukuran array (yaitu jumlah total entri dalam array): a.size # Output: 4 Selanjutnya membuat array NumPy 2D (dua dimensi) (yaitu matriks): M = np.array([[1,2],[3,7],[-1,5]]) print(M) # Output: # [[ 1 2] # [ 3 7] # [-1 5]] Verifikasi jumlah dimensi: M.ndim # Output: 2 Verifikasi bentuk array: M.shape # Output: (3, 2) Terakhir, verifikasi jumlah total entri dalam array: M.size # Output: 6 Pilih baris atau kolom dari array NumPy 2D dan kami mendapatkan array 1D: col = M[:,1] print(col) # Output: [2 7 5] Verifikasi jumlah dimensi potongan: col.ndim # Output: 1 Verifikasi bentuk dan ukuran potongan: col.shape # Output: (3,) col.size # Output: 3 Saat kita memilih baris kolom dari array NumPy 2D, hasilnya adalah array NumPy 1D. Namun, kami mungkin ingin memilih kolom sebagai vektor kolom 2D. Ini mengharuskan kita untuk menggunakan metode reshape . Misalnya, buat vektor kolom 2D dari potongan 1D yang dipilih dari matriks M di atas: print(col) # Output: [2 7 5] column = np.array([2,7,5]).reshape(3,1) print(column) # Output: # [[2] # [7] # [5]] Verifikasi dimensi, bentuk, dan ukuran array: print('Dimensions:', column.ndim) print('Shape:', column.shape) print('Size:', column.size) # Output: # Dimensions: 2 # Shape: (3, 1) # Size: 3 Variabel col dan column adalah berbagai jenis objek meskipun mereka memiliki data yang \"sama\". print(col) # Output: [2 7 5] print('Dimensions:', column.ndim) print('Shape:', column.shape) print('Size:', column.size) # Output: # Dimensions: 2 # Shape: (3, 1) # Size: 3","title":"Atribut Array"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#operasi-dan-fungsi-matriks","text":"","title":"Operasi dan Fungsi Matriks"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#operasi-aritmatika","text":"Ingat bahwa operasi array aritmatika +, -, /, * dan ** dilakukan secara elementwise pada array NumPy. Mari kita membuat array NumPy dan melakukan beberapa komputasi: M = np.array([[3,4],[-1,5]]) print(M) # Output: # [[ 3 4] # [-1 5]] M * M # Output: # array([[ 9, 16], # [ 1, 25]])","title":"Operasi Aritmatika"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#perkalian-matriks","text":"Kami menggunakan operator @ untuk melakukan perkalian matriks dengan array NumPy: M @ M # Output: # array([[ 5, 32], # [-8, 21]]) Mari kita menghitung \\(2I + 3A - AB\\) untuk \\[ A = \\begin{bmatrix} 1 & 3 \\\\ -1 & 7 \\end{bmatrix} \\ \\ \\ \\ B = \\begin{bmatrix} 5 & 2 \\\\ 1 & 2 \\end{bmatrix} \\] dan \\(I\\) adalah matriks identitas ukuran 2: A = np.array([[1,3],[-1,7]]) print(A) # Output: # [[ 1 3] # [-1 7]] B = np.array([[5,2],[1,2]]) print(B) # Output: # [[5 2] # [1 2]] I = np.eye(2) print(I) # Output: # [[1. 0.] # [0. 1.]] 2*I + 3*A - A@B # Output: # array([[-3., 1.], # [-5., 11.]])","title":"Perkalian Matriks"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#matrix-powers","text":"Tidak ada simbol untuk matrix power dan jadi kita harus mengimpor fungsi matrix_power dari subpackage numpy.linalg. from numpy.linalg import matrix_power as mpow M = np.array([[3,4],[-1,5]]) print(M) # Output: # [[ 3 4] # [-1 5]] mpow(M,5) # Output: # array([[-1525, 3236], # [ -809, 93]]) Bandingkan dengan operator perkalian matriks: M @ M @ M @ M @ M # Output: # array([[-1525, 3236], # [ -809, 93]]) mpow(M,3) # Output: # array([[-17, 180], # [-45, 73]]) M @ M @ M # Output: # array([[-17, 180], # [-45, 73]])","title":"Matrix Powers"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#tranpose","text":"Kita bisa mengambil transpose dengan atribut .T: print(M) # Output: # [[ 3 4] # [-1 5]] print(M.T) # Output: # [[ 3 -1] # [ 4 5]] perhatikan bahwa \\(MM^T\\) adalah matriks simetris: M @ M.T # Output: # array([[25, 17], # [17, 26]])","title":"Tranpose"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#inverse","text":"Kita dapat menemukan inversi menggunakan fungsi scipy.linalg.inv: A = np.array([[1,2],[3,4]]) print(A) # Output: # [[1 2] # [3 4]] la.inv(A) # Output: # array([[-2. , 1. ], # [ 1.5, -0.5]])","title":"Inverse"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#trace","text":"Kita dapat menemukan trace matriks menggunakan fungsi numpy.trace: np.trace(A) # Output: 5","title":"Trace"},{"location":"Aljabar%20Linear/02_Aljabar%20Linear%20dengan%20SciPy/#determinant","text":"Kita menemukan determinan menggunakan fungsi scipy.linalg.det: A = np.array([[1,2],[3,4]]) print(A) # Output: # [[1 2] # [3 4]] la.det(A) # Output: -2.0","title":"Determinant"},{"location":"Aljabar%20Linear/03_Memecahkan%20Sistem%20Linear/","text":"Memecahkan Sistem Linear Pertama, kita siapkan beberapa package python yang akan kita gunakan disini: import numpy as np import matplotlib.pyplot as plt import scipy.linalg as la %matplotlib inline Sistem Linear Sistem persamaan linear adalah kumpulan persamaan linear \\[ \\begin{align} a_{0,0}x_0 + a_{0,1}x_2 + \\cdots + a_{0,n}x_n & = b_0 \\\\ a_{1,0}x_0 + a_{1,1}x_2 + \\cdots + a_{1,n}x_n & = b_1 \\\\ & \\vdots \\\\ a_{m,0}x_0 + a_{m,1}x_2 + \\cdots + a_{m,n}x_n & = b_m \\\\ \\end{align} \\] Dalam notasi matriks, sistem linear adalah \\(A \\mathbf{x}= \\mathbf{b}\\) di mana \\[ A = \\begin{bmatrix} a_{0,0} & a_{0,1} & \\cdots & a_{0,n} \\\\ a_{1,0} & a_{1,1} & \\cdots & a_{1,n} \\\\ \\vdots & & & \\vdots \\\\ a_{m,0} & a_{m,1} & \\cdots & a_{m,n} \\\\ \\end{bmatrix} \\ \\ , \\ \\ \\mathbf{x} = \\begin{bmatrix} x_0 \\\\ x_1 \\\\ \\vdots \\\\ x_n \\end{bmatrix} \\ \\ , \\ \\ \\mathbf{b} = \\begin{bmatrix} b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_m \\end{bmatrix} \\] Eliminasi Gauss Prosedur umum untuk menyelesaikan sistem persamaan linier disebut eliminasi Gaussian. Idenya adalah untuk melakukan operasi baris dasar untuk mengurangi sistem ke bentuk eselon barisnya dan kemudian memecahkannya. Operasi Baris Dasar Operasi baris dasar meliputi: Tambahkan \\(k\\) kali baris \\(j\\) ke baris \\(i\\) . Kalikan baris \\(i\\) dengan skalar \\(k\\) . Tukar baris \\(i\\) dan \\(j\\) . Masing-masing operasi baris dasar adalah hasil perkalian matriks oleh matriks dasar (di sebelah kiri). Untuk menambahkan \\(k\\) kali baris \\(i\\) ke baris \\(j\\) dalam matriks \\(A\\) , kita akan mengalikan \\(A\\) dengan matriks \\(E\\) di mana \\(E\\) sama dengan matriks identitas kecuali entri \\(i,j\\) adalah \\(E_{i,j} = k\\) . Misalnya, jika \\(A\\) adalah 3 kali 3 dan kita ingin menambahkan 3 kali baris 2 ke baris 0 (menggunakan 0 pengindeksan) maka \\[ E_1 = \\begin{bmatrix} 1 & 0 & 3 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} \\] Mari kita verifikasi perhitungannya: A = np.array([[1,1,2],[-1,3,1],[0,5,2]]) print(A) # Output: # [[ 1 1 2] # [-1 3 1] # [ 0 5 2]] E1 = np.array([[1,0,3],[0,1,0],[0,0,1]]) print(E1) # Output: # [[1 0 3] # [0 1 0] # [0 0 1]] E1 @ A # Output: # array([[ 1, 16, 8], # [-1, 3, 1], # [ 0, 5, 2]]) Selanjutnya, untuk menukar baris \\(i\\) dan baris \\(j\\) dalam matriks \\(A\\) , kami mengalikan \\(A\\) dengan matriks \\(E\\) di mana \\(E\\) sama dengan matriks identitas kecuali \\(E_{i,i} = 0\\) , \\(E_{j,j} = 0\\) , \\(E_{i,j} = 1\\) , dan \\(E_{j,i} = 1\\) . Misalnya, jika \\(A\\) adalah 3 kali 3 dan kita ingin menukar baris 1 dan baris 2 maka \\[ E^3 = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 1 & 0 \\end{bmatrix} \\] Mari kita verifikasi perhitungan: E3 = np.array([[1,0,0],[0,0,1],[0,1,0]]) print(E3) # Output: # [[1 0 0] # [0 0 1] # [0 1 0]] E3 @ A # Output: # array([[ 1, 1, 2], # [ 0, 5, 2], # [-1, 3, 1]]) Implementasi Mari kita tulis fungsi untuk mengimplementasikan operasi baris dasar. Pertama-tama, mari kita tulis fungsi yang dengan nama add_rows yang mengambil parameter input \\(A\\) , \\(k\\) , \\(i\\) dan \\(j\\) dan mengembalikan array NumPy yang dihasilkan dari menambahkan \\(k\\) kali baris \\(j\\) ke baris \\(i\\) dalam matriks \\(A\\) . Jika \\(i=j\\) , kemudian katakanlah bahwa fungsi menskalakan baris \\(i\\) oleh \\(k+1\\) karena ini akan menjadi hasil \\(k\\) kali baris \\(i\\) ditambahkan ke baris \\(i\\) . def add_row(A,k,i,j): \"Tambahkan k kali baris j ke baris i dalam matriks A.\" n = A.shape[0] E = np.eye(n) if i == j: E[i,i] = k + 1 else: E[i,j] = k return E @ A Mari kita uji fungsi kita: M = np.array([[1,1],[3,2]]) print(M) # Output: # [[1 1] # [3 2]] add_row(M,2,0,1) # Output: # array([[7., 5.], # [3., 2.]]) add_row(M,3,1,1) # Output: # array([[ 1., 1.], # [12., 8.]]) Mari kita tulis fungsi dengan nama scale_row yang mengambil 3 parameter input \\(A\\) , \\(k\\) , dan \\(i\\) dan mengembalikan matriks yang hasil dari \\(k\\) kali baris \\(i\\) dalam matriks \\(A\\) . def scale_row(A,k,i): \"Kalikan baris i dengan k dalam matriks A.\" n = A.shape[0] E = np.eye(n) E[i,i] = k return E @ A M = np.array([[3,1],[-2,7]]) print(M) # Output: # [[ 3 1] # [-2 7]] scale_row(M,3,1) # Output: # array([[ 3., 1.], # [-6., 21.]]) A = np.array([[1,1,1],[1,-1,0]]) print(A) # Output: # [[ 1 1 1] # [ 1 -1 0]] scale_row(A,5,1) # Output: # array([[ 1., 1., 1.], # [ 5., -5., 0.]]) Mari kita tulis fungsi dengan nama switch_rows yang mengambil 3 parameter input \\(A\\) , \\(i\\) , dan \\(j\\) dan mengembalikan matriks hasil pertukaran baris \\(i\\) dan \\(j\\) dalam matriks \\(A\\) . def switch_rows(A,i,j): \"Switch rows i and j in matrix A.\" n = A.shape[0] E = np.eye(n) E[i,i] = 0 E[j,j] = 0 E[i,j] = 1 E[j,i] = 1 return E @ A A = np.array([[1,1,1],[1,-1,0]]) print(A) # Output: # [[ 1 1 1] # [ 1 -1 0]] switch_rows(A,0,1) # Output: # array([[ 1., -1., 0.], # [ 1., 1., 1.]]) Contoh Menemukan Inversi Mari kita terapkan fungsi kita ke matriks augmented \\([M \\ | \\ I]\\) untuk menemukan inversi matriks \\(M\\) : M = np.array([[5,4,2],[-1,2,1],[1,1,1]]) print(M) # Output: # [[ 5 4 2] # [-1 2 1] # [ 1 1 1]] A = np.hstack([M,np.eye(3)]) print(A) # Output: # [[ 5. 4. 2. 1. 0. 0.] # [-1. 2. 1. 0. 1. 0.] # [ 1. 1. 1. 0. 0. 1.]] A1 = switch_rows(A,0,2) print(A1) # Output: # [[ 1. 1. 1. 0. 0. 1.] # [-1. 2. 1. 0. 1. 0.] # [ 5. 4. 2. 1. 0. 0.]] A2 = add_row(A1,1,1,0) print(A2) # Output: # [[1. 1. 1. 0. 0. 1.] # [0. 3. 2. 0. 1. 1.] # [5. 4. 2. 1. 0. 0.]] A3 = add_row(A2,-5,2,0) print(A3) # Output: # [[ 1. 1. 1. 0. 0. 1.] # [ 0. 3. 2. 0. 1. 1.] # [ 0. -1. -3. 1. 0. -5.]] A4 = switch_rows(A3,1,2) print(A4) # Output: # [[ 1. 1. 1. 0. 0. 1.] # [ 0. -1. -3. 1. 0. -5.] # [ 0. 3. 2. 0. 1. 1.]] A5 = scale_row(A4,-1,1) print(A5) # Output: # [[ 1. 1. 1. 0. 0. 1.] # [ 0. 1. 3. -1. 0. 5.] # [ 0. 3. 2. 0. 1. 1.]] A6 = add_row(A5,-3,2,1) print(A6) # Output: # [[ 1. 1. 1. 0. 0. 1.] # [ 0. 1. 3. -1. 0. 5.] # [ 0. 0. -7. 3. 1. -14.]] A7 = scale_row(A6,-1/7,2) print(A7) # Output: # [[ 1. 1. 1. 0. 0. 1. ] # [ 0. 1. 3. -1. 0. 5. ] # [ 0. 0. 1. -0.42857143 -0.14285714 2. ]] A8 = add_row(A7,-3,1,2) print(A8) # Output: # [[ 1. 1. 1. 0. 0. 1. ] # [ 0. 1. 0. 0.28571429 0.42857143 -1. ] # [ 0. 0. 1. -0.42857143 -0.14285714 2. ]] A9 = add_row(A8,-1,0,2) print(A9) # Output: # [[ 1. 1. 0. 0.42857143 0.14285714 -1. ] # [ 0. 1. 0. 0.28571429 0.42857143 -1. ] # [ 0. 0. 1. -0.42857143 -0.14285714 2. ]] A10 = add_row(A9,-1,0,1) print(A10) # Output: # [[ 1. 0. 0. 0.14285714 -0.28571429 0. ] # [ 0. 1. 0. 0.28571429 0.42857143 -1. ] # [ 0. 0. 1. -0.42857143 -0.14285714 2. ]] Mari kita verifikasi bahwa kita menemukan \\(M^{-1}\\) terbalik dengan benar: Minv = A10[:,3:] print(Minv) # Output: # [[ 0.14285714 -0.28571429 0. ] # [ 0.28571429 0.42857143 -1. ] # [-0.42857143 -0.14285714 2. ]] result = Minv @ M print(result) # Output: # [[ 1.00000000e+00 4.44089210e-16 2.22044605e-16] # [-6.66133815e-16 1.00000000e+00 -2.22044605e-16] # [ 0.00000000e+00 0.00000000e+00 1.00000000e+00]] Berhasil! Kita dapat melihat hasilnya lebih jelas jika kita membulatkan ke 15 tempat desimal: np.round(result,15) # Output: # array([[ 1.e+00, 0.e+00, 0.e+00], # [-1.e-15, 1.e+00, -0.e+00], # [ 0.e+00, 0.e+00, 1.e+00]]) Memecahkan Sistem Mari kita gunakan fungsi kita untuk melakukan eliminasi Gaussian dan memecahkan sistem persamaan linier \\(A \\mathbf{x} = \\mathbf{b}\\) . A = np.array([[6,15,1],[8,7,12],[2,7,8]]) print(A) # Output: # [[ 6 15 1] # [ 8 7 12] # [ 2 7 8]] b = np.array([[2],[14],[10]]) print(b) # Output: # [[ 2] # [14] # [10]] Membentuk matriks augmented \\(M\\) : M = np.hstack([A,b]) print(M) # Output: # [[ 6 15 1 2] # [ 8 7 12 14] # [ 2 7 8 10]] Melakukan operasi baris: M1 = scale_row(M,1/6,0) print(M1) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 8. 7. 12. 14. ] # [ 2. 7. 8. 10. ]] M2 = add_row(M1,-8,1,0) print(M2) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 0. -13. 10.66666667 11.33333333] # [ 2. 7. 8. 10. ]] M3 = add_row(M2,-2,2,0) print(M3) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 0. -13. 10.66666667 11.33333333] # [ 0. 2. 7.66666667 9.33333333]] M4 = scale_row(M3,-1/13,1) print(M4) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 0. 1. -0.82051282 -0.87179487] # [ 0. 2. 7.66666667 9.33333333]] M5 = add_row(M4,-2,2,1) print(M5) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 0. 1. -0.82051282 -0.87179487] # [ 0. 0. 9.30769231 11.07692308]] M6 = scale_row(M5,1/M5[2,2],2) print(M6) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 0. 1. -0.82051282 -0.87179487] # [ 0. 0. 1. 1.19008264]] M7 = add_row(M6,-M6[1,2],1,2) print(M7) # Output: # [[1. 2.5 0.16666667 0.33333333] # [0. 1. 0. 0.1046832 ] # [0. 0. 1. 1.19008264]] M8 = add_row(M7,-M7[0,2],0,2) print(M8) # Output: # [[1. 2.5 0. 0.13498623] # [0. 1. 0. 0.1046832 ] # [0. 0. 1. 1.19008264]] M9 = add_row(M8,-M8[0,1],0,1) print(M9) # Output: # [[ 1. 0. 0. -0.12672176] # [ 0. 1. 0. 0.1046832 ] # [ 0. 0. 1. 1.19008264]] Berhasil! Solusi dari \\(Ax=b\\) adalah: x = M9[:,3].reshape(3,1) print(x) # Output: # [[-0.12672176] # [ 0.1046832 ] # [ 1.19008264]] Atau, kita bisa melakukannya dengan cara yang mudah... x = la.solve(A,b) print(x) # Output: # [[-0.12672176] # [ 0.1046832 ] # [ 1.19008264]]","title":"Memecahkan Sistem Linear"},{"location":"Aljabar%20Linear/03_Memecahkan%20Sistem%20Linear/#memecahkan-sistem-linear","text":"Pertama, kita siapkan beberapa package python yang akan kita gunakan disini: import numpy as np import matplotlib.pyplot as plt import scipy.linalg as la %matplotlib inline","title":"Memecahkan Sistem Linear"},{"location":"Aljabar%20Linear/03_Memecahkan%20Sistem%20Linear/#sistem-linear","text":"Sistem persamaan linear adalah kumpulan persamaan linear \\[ \\begin{align} a_{0,0}x_0 + a_{0,1}x_2 + \\cdots + a_{0,n}x_n & = b_0 \\\\ a_{1,0}x_0 + a_{1,1}x_2 + \\cdots + a_{1,n}x_n & = b_1 \\\\ & \\vdots \\\\ a_{m,0}x_0 + a_{m,1}x_2 + \\cdots + a_{m,n}x_n & = b_m \\\\ \\end{align} \\] Dalam notasi matriks, sistem linear adalah \\(A \\mathbf{x}= \\mathbf{b}\\) di mana \\[ A = \\begin{bmatrix} a_{0,0} & a_{0,1} & \\cdots & a_{0,n} \\\\ a_{1,0} & a_{1,1} & \\cdots & a_{1,n} \\\\ \\vdots & & & \\vdots \\\\ a_{m,0} & a_{m,1} & \\cdots & a_{m,n} \\\\ \\end{bmatrix} \\ \\ , \\ \\ \\mathbf{x} = \\begin{bmatrix} x_0 \\\\ x_1 \\\\ \\vdots \\\\ x_n \\end{bmatrix} \\ \\ , \\ \\ \\mathbf{b} = \\begin{bmatrix} b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_m \\end{bmatrix} \\]","title":"Sistem Linear"},{"location":"Aljabar%20Linear/03_Memecahkan%20Sistem%20Linear/#eliminasi-gauss","text":"Prosedur umum untuk menyelesaikan sistem persamaan linier disebut eliminasi Gaussian. Idenya adalah untuk melakukan operasi baris dasar untuk mengurangi sistem ke bentuk eselon barisnya dan kemudian memecahkannya.","title":"Eliminasi Gauss"},{"location":"Aljabar%20Linear/03_Memecahkan%20Sistem%20Linear/#operasi-baris-dasar","text":"Operasi baris dasar meliputi: Tambahkan \\(k\\) kali baris \\(j\\) ke baris \\(i\\) . Kalikan baris \\(i\\) dengan skalar \\(k\\) . Tukar baris \\(i\\) dan \\(j\\) . Masing-masing operasi baris dasar adalah hasil perkalian matriks oleh matriks dasar (di sebelah kiri). Untuk menambahkan \\(k\\) kali baris \\(i\\) ke baris \\(j\\) dalam matriks \\(A\\) , kita akan mengalikan \\(A\\) dengan matriks \\(E\\) di mana \\(E\\) sama dengan matriks identitas kecuali entri \\(i,j\\) adalah \\(E_{i,j} = k\\) . Misalnya, jika \\(A\\) adalah 3 kali 3 dan kita ingin menambahkan 3 kali baris 2 ke baris 0 (menggunakan 0 pengindeksan) maka \\[ E_1 = \\begin{bmatrix} 1 & 0 & 3 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} \\] Mari kita verifikasi perhitungannya: A = np.array([[1,1,2],[-1,3,1],[0,5,2]]) print(A) # Output: # [[ 1 1 2] # [-1 3 1] # [ 0 5 2]] E1 = np.array([[1,0,3],[0,1,0],[0,0,1]]) print(E1) # Output: # [[1 0 3] # [0 1 0] # [0 0 1]] E1 @ A # Output: # array([[ 1, 16, 8], # [-1, 3, 1], # [ 0, 5, 2]]) Selanjutnya, untuk menukar baris \\(i\\) dan baris \\(j\\) dalam matriks \\(A\\) , kami mengalikan \\(A\\) dengan matriks \\(E\\) di mana \\(E\\) sama dengan matriks identitas kecuali \\(E_{i,i} = 0\\) , \\(E_{j,j} = 0\\) , \\(E_{i,j} = 1\\) , dan \\(E_{j,i} = 1\\) . Misalnya, jika \\(A\\) adalah 3 kali 3 dan kita ingin menukar baris 1 dan baris 2 maka \\[ E^3 = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 1 & 0 \\end{bmatrix} \\] Mari kita verifikasi perhitungan: E3 = np.array([[1,0,0],[0,0,1],[0,1,0]]) print(E3) # Output: # [[1 0 0] # [0 0 1] # [0 1 0]] E3 @ A # Output: # array([[ 1, 1, 2], # [ 0, 5, 2], # [-1, 3, 1]])","title":"Operasi Baris Dasar"},{"location":"Aljabar%20Linear/03_Memecahkan%20Sistem%20Linear/#implementasi","text":"Mari kita tulis fungsi untuk mengimplementasikan operasi baris dasar. Pertama-tama, mari kita tulis fungsi yang dengan nama add_rows yang mengambil parameter input \\(A\\) , \\(k\\) , \\(i\\) dan \\(j\\) dan mengembalikan array NumPy yang dihasilkan dari menambahkan \\(k\\) kali baris \\(j\\) ke baris \\(i\\) dalam matriks \\(A\\) . Jika \\(i=j\\) , kemudian katakanlah bahwa fungsi menskalakan baris \\(i\\) oleh \\(k+1\\) karena ini akan menjadi hasil \\(k\\) kali baris \\(i\\) ditambahkan ke baris \\(i\\) . def add_row(A,k,i,j): \"Tambahkan k kali baris j ke baris i dalam matriks A.\" n = A.shape[0] E = np.eye(n) if i == j: E[i,i] = k + 1 else: E[i,j] = k return E @ A Mari kita uji fungsi kita: M = np.array([[1,1],[3,2]]) print(M) # Output: # [[1 1] # [3 2]] add_row(M,2,0,1) # Output: # array([[7., 5.], # [3., 2.]]) add_row(M,3,1,1) # Output: # array([[ 1., 1.], # [12., 8.]]) Mari kita tulis fungsi dengan nama scale_row yang mengambil 3 parameter input \\(A\\) , \\(k\\) , dan \\(i\\) dan mengembalikan matriks yang hasil dari \\(k\\) kali baris \\(i\\) dalam matriks \\(A\\) . def scale_row(A,k,i): \"Kalikan baris i dengan k dalam matriks A.\" n = A.shape[0] E = np.eye(n) E[i,i] = k return E @ A M = np.array([[3,1],[-2,7]]) print(M) # Output: # [[ 3 1] # [-2 7]] scale_row(M,3,1) # Output: # array([[ 3., 1.], # [-6., 21.]]) A = np.array([[1,1,1],[1,-1,0]]) print(A) # Output: # [[ 1 1 1] # [ 1 -1 0]] scale_row(A,5,1) # Output: # array([[ 1., 1., 1.], # [ 5., -5., 0.]]) Mari kita tulis fungsi dengan nama switch_rows yang mengambil 3 parameter input \\(A\\) , \\(i\\) , dan \\(j\\) dan mengembalikan matriks hasil pertukaran baris \\(i\\) dan \\(j\\) dalam matriks \\(A\\) . def switch_rows(A,i,j): \"Switch rows i and j in matrix A.\" n = A.shape[0] E = np.eye(n) E[i,i] = 0 E[j,j] = 0 E[i,j] = 1 E[j,i] = 1 return E @ A A = np.array([[1,1,1],[1,-1,0]]) print(A) # Output: # [[ 1 1 1] # [ 1 -1 0]] switch_rows(A,0,1) # Output: # array([[ 1., -1., 0.], # [ 1., 1., 1.]])","title":"Implementasi"},{"location":"Aljabar%20Linear/03_Memecahkan%20Sistem%20Linear/#contoh","text":"","title":"Contoh"},{"location":"Aljabar%20Linear/03_Memecahkan%20Sistem%20Linear/#menemukan-inversi","text":"Mari kita terapkan fungsi kita ke matriks augmented \\([M \\ | \\ I]\\) untuk menemukan inversi matriks \\(M\\) : M = np.array([[5,4,2],[-1,2,1],[1,1,1]]) print(M) # Output: # [[ 5 4 2] # [-1 2 1] # [ 1 1 1]] A = np.hstack([M,np.eye(3)]) print(A) # Output: # [[ 5. 4. 2. 1. 0. 0.] # [-1. 2. 1. 0. 1. 0.] # [ 1. 1. 1. 0. 0. 1.]] A1 = switch_rows(A,0,2) print(A1) # Output: # [[ 1. 1. 1. 0. 0. 1.] # [-1. 2. 1. 0. 1. 0.] # [ 5. 4. 2. 1. 0. 0.]] A2 = add_row(A1,1,1,0) print(A2) # Output: # [[1. 1. 1. 0. 0. 1.] # [0. 3. 2. 0. 1. 1.] # [5. 4. 2. 1. 0. 0.]] A3 = add_row(A2,-5,2,0) print(A3) # Output: # [[ 1. 1. 1. 0. 0. 1.] # [ 0. 3. 2. 0. 1. 1.] # [ 0. -1. -3. 1. 0. -5.]] A4 = switch_rows(A3,1,2) print(A4) # Output: # [[ 1. 1. 1. 0. 0. 1.] # [ 0. -1. -3. 1. 0. -5.] # [ 0. 3. 2. 0. 1. 1.]] A5 = scale_row(A4,-1,1) print(A5) # Output: # [[ 1. 1. 1. 0. 0. 1.] # [ 0. 1. 3. -1. 0. 5.] # [ 0. 3. 2. 0. 1. 1.]] A6 = add_row(A5,-3,2,1) print(A6) # Output: # [[ 1. 1. 1. 0. 0. 1.] # [ 0. 1. 3. -1. 0. 5.] # [ 0. 0. -7. 3. 1. -14.]] A7 = scale_row(A6,-1/7,2) print(A7) # Output: # [[ 1. 1. 1. 0. 0. 1. ] # [ 0. 1. 3. -1. 0. 5. ] # [ 0. 0. 1. -0.42857143 -0.14285714 2. ]] A8 = add_row(A7,-3,1,2) print(A8) # Output: # [[ 1. 1. 1. 0. 0. 1. ] # [ 0. 1. 0. 0.28571429 0.42857143 -1. ] # [ 0. 0. 1. -0.42857143 -0.14285714 2. ]] A9 = add_row(A8,-1,0,2) print(A9) # Output: # [[ 1. 1. 0. 0.42857143 0.14285714 -1. ] # [ 0. 1. 0. 0.28571429 0.42857143 -1. ] # [ 0. 0. 1. -0.42857143 -0.14285714 2. ]] A10 = add_row(A9,-1,0,1) print(A10) # Output: # [[ 1. 0. 0. 0.14285714 -0.28571429 0. ] # [ 0. 1. 0. 0.28571429 0.42857143 -1. ] # [ 0. 0. 1. -0.42857143 -0.14285714 2. ]] Mari kita verifikasi bahwa kita menemukan \\(M^{-1}\\) terbalik dengan benar: Minv = A10[:,3:] print(Minv) # Output: # [[ 0.14285714 -0.28571429 0. ] # [ 0.28571429 0.42857143 -1. ] # [-0.42857143 -0.14285714 2. ]] result = Minv @ M print(result) # Output: # [[ 1.00000000e+00 4.44089210e-16 2.22044605e-16] # [-6.66133815e-16 1.00000000e+00 -2.22044605e-16] # [ 0.00000000e+00 0.00000000e+00 1.00000000e+00]] Berhasil! Kita dapat melihat hasilnya lebih jelas jika kita membulatkan ke 15 tempat desimal: np.round(result,15) # Output: # array([[ 1.e+00, 0.e+00, 0.e+00], # [-1.e-15, 1.e+00, -0.e+00], # [ 0.e+00, 0.e+00, 1.e+00]])","title":"Menemukan Inversi"},{"location":"Aljabar%20Linear/03_Memecahkan%20Sistem%20Linear/#memecahkan-sistem","text":"Mari kita gunakan fungsi kita untuk melakukan eliminasi Gaussian dan memecahkan sistem persamaan linier \\(A \\mathbf{x} = \\mathbf{b}\\) . A = np.array([[6,15,1],[8,7,12],[2,7,8]]) print(A) # Output: # [[ 6 15 1] # [ 8 7 12] # [ 2 7 8]] b = np.array([[2],[14],[10]]) print(b) # Output: # [[ 2] # [14] # [10]] Membentuk matriks augmented \\(M\\) : M = np.hstack([A,b]) print(M) # Output: # [[ 6 15 1 2] # [ 8 7 12 14] # [ 2 7 8 10]] Melakukan operasi baris: M1 = scale_row(M,1/6,0) print(M1) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 8. 7. 12. 14. ] # [ 2. 7. 8. 10. ]] M2 = add_row(M1,-8,1,0) print(M2) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 0. -13. 10.66666667 11.33333333] # [ 2. 7. 8. 10. ]] M3 = add_row(M2,-2,2,0) print(M3) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 0. -13. 10.66666667 11.33333333] # [ 0. 2. 7.66666667 9.33333333]] M4 = scale_row(M3,-1/13,1) print(M4) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 0. 1. -0.82051282 -0.87179487] # [ 0. 2. 7.66666667 9.33333333]] M5 = add_row(M4,-2,2,1) print(M5) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 0. 1. -0.82051282 -0.87179487] # [ 0. 0. 9.30769231 11.07692308]] M6 = scale_row(M5,1/M5[2,2],2) print(M6) # Output: # [[ 1. 2.5 0.16666667 0.33333333] # [ 0. 1. -0.82051282 -0.87179487] # [ 0. 0. 1. 1.19008264]] M7 = add_row(M6,-M6[1,2],1,2) print(M7) # Output: # [[1. 2.5 0.16666667 0.33333333] # [0. 1. 0. 0.1046832 ] # [0. 0. 1. 1.19008264]] M8 = add_row(M7,-M7[0,2],0,2) print(M8) # Output: # [[1. 2.5 0. 0.13498623] # [0. 1. 0. 0.1046832 ] # [0. 0. 1. 1.19008264]] M9 = add_row(M8,-M8[0,1],0,1) print(M9) # Output: # [[ 1. 0. 0. -0.12672176] # [ 0. 1. 0. 0.1046832 ] # [ 0. 0. 1. 1.19008264]] Berhasil! Solusi dari \\(Ax=b\\) adalah: x = M9[:,3].reshape(3,1) print(x) # Output: # [[-0.12672176] # [ 0.1046832 ] # [ 1.19008264]] Atau, kita bisa melakukannya dengan cara yang mudah... x = la.solve(A,b) print(x) # Output: # [[-0.12672176] # [ 0.1046832 ] # [ 1.19008264]]","title":"Memecahkan Sistem"},{"location":"Integrasi%20Numerik/01_Pengantar/","text":"Pengantar Integrasi numerik adalah perkiraan komputasi integral menggunakan teknik numerik. Perhitungan numerik dari integral kadang-kadang disebut kuadratur. Mengapa kita membutuhkannya? Banyak integral tidak dapat dievaluasi secara analitis. Bahkan jika kita bisa, kita mungkin perlu memeriksa jawaban tersebut. Bahkan jika kita bisa, evaluasi numerik jawaban dapat mengganggu. Contoh sederhana Temukan \\(\\int 1dx\\) \\(\\int \\left( 3x-1\\right) ^{4}dx\\) Solusi Kita dapat mengamati secara langsung bahwa x adalah antiderivatif 1, atau kita dapat menggunakan aturan di atas untuk antiderivatif \\(x^{n}\\) dimana \\(n=0\\) . Bagaimanapun, antiderivatif umum adalah \\(x + c\\) dan \\(\\int 1dx = x + c\\) , di mana \\(c\\) adalah konstanta. Menggunakan aturan di atas untuk antiderivatif \\((ax+b)^n\\) dengan \\(a = 3, b = -1, n = 4\\) . Maka diperoleh \\(\\int \\left( 3x-1\\right) ^{4}dx=\\dfrac{1}{15}\\left( 3x-1\\right) ^{5}+c\\) , dimana \\(c\\) adalah konstanta. Integral Tak Tentu Integrasi yang tidak terbatas, juga dikenal sebagai antiderivatif, adalah pembalikan proses turunan. Ini dapat dinyatakan secara simbolis sebagai \\(F' = f\\) . Notasi Integral Tak Tentu \\[ \\int f\\left( x\\right) dx=f\\left( x\\right) +c \\] Formula Dasar Integral Tak Tentu \\[ \\int ax^{n}dx=\\dfrac{a}{n+1}x^{n+}+c \\] Contoh \\[ \\int 4x^{5}dx=\\dfrac{4}{6}x^{6}+c=\\dfrac{2}{3}x^{6}+c \\] dan jika diimplementasikan menggunakan Python dengan bantuan library sympy akan seperti berikut: import sympy as sp x = sp.Symbol('x') sp.integrate(4*x**5, x) output yang dihasilkan seperti berikut: \\[ \\dfrac{2x^{6}}{3} \\] mari kita coba contoh lain seperti berikut: \\[ \\int \\left( 6x^{2}+4x-6\\right) dx=\\dfrac{6}{3}x^{3}+\\dfrac{4}{2}x^{2}-6x+c \\] pada contoh diatas dapat kita uraikan: \\(\\int 6x^{2} = \\dfrac{6}{3}x^{3}\\) \\(4x = 4x^{1}\\) , maka \\(\\int 4x = \\dfrac{4}{2}x^{2}\\) \\(6 = 6x^{0}\\) , maka \\(\\int 6x = \\dfrac{6}{1}x^{1} = 6x\\) hasil nya juga dapat kita sederhanakan menjadi: \\[ \\int \\left( 6x^{2}+4x-6\\right) dx = 2x^{3} + 2x^{2} - 6x \\] maka jika kita implementasikan pada python akan seperti berikut: import sympy as sp x = sp.Symbol('x') sp.integrate((6*x**2 + 4*x - 6), x) Referensi : Integrasi Numerik oleh Rinaldi Munir (IF-STEI ITB) Integrasi Numerik.ppt Integrasi Numerik - UNY 6.6.2 Metode Romberg","title":"Pengantar"},{"location":"Integrasi%20Numerik/01_Pengantar/#pengantar","text":"Integrasi numerik adalah perkiraan komputasi integral menggunakan teknik numerik. Perhitungan numerik dari integral kadang-kadang disebut kuadratur.","title":"Pengantar"},{"location":"Integrasi%20Numerik/01_Pengantar/#mengapa-kita-membutuhkannya","text":"Banyak integral tidak dapat dievaluasi secara analitis. Bahkan jika kita bisa, kita mungkin perlu memeriksa jawaban tersebut. Bahkan jika kita bisa, evaluasi numerik jawaban dapat mengganggu.","title":"Mengapa kita membutuhkannya?"},{"location":"Integrasi%20Numerik/01_Pengantar/#contoh-sederhana","text":"Temukan \\(\\int 1dx\\) \\(\\int \\left( 3x-1\\right) ^{4}dx\\) Solusi Kita dapat mengamati secara langsung bahwa x adalah antiderivatif 1, atau kita dapat menggunakan aturan di atas untuk antiderivatif \\(x^{n}\\) dimana \\(n=0\\) . Bagaimanapun, antiderivatif umum adalah \\(x + c\\) dan \\(\\int 1dx = x + c\\) , di mana \\(c\\) adalah konstanta. Menggunakan aturan di atas untuk antiderivatif \\((ax+b)^n\\) dengan \\(a = 3, b = -1, n = 4\\) . Maka diperoleh \\(\\int \\left( 3x-1\\right) ^{4}dx=\\dfrac{1}{15}\\left( 3x-1\\right) ^{5}+c\\) , dimana \\(c\\) adalah konstanta.","title":"Contoh sederhana"},{"location":"Integrasi%20Numerik/01_Pengantar/#integral-tak-tentu","text":"Integrasi yang tidak terbatas, juga dikenal sebagai antiderivatif, adalah pembalikan proses turunan. Ini dapat dinyatakan secara simbolis sebagai \\(F' = f\\) .","title":"Integral Tak Tentu"},{"location":"Integrasi%20Numerik/01_Pengantar/#notasi-integral-tak-tentu","text":"\\[ \\int f\\left( x\\right) dx=f\\left( x\\right) +c \\]","title":"Notasi Integral Tak Tentu"},{"location":"Integrasi%20Numerik/01_Pengantar/#formula-dasar-integral-tak-tentu","text":"\\[ \\int ax^{n}dx=\\dfrac{a}{n+1}x^{n+}+c \\]","title":"Formula Dasar Integral Tak Tentu"},{"location":"Integrasi%20Numerik/01_Pengantar/#contoh","text":"\\[ \\int 4x^{5}dx=\\dfrac{4}{6}x^{6}+c=\\dfrac{2}{3}x^{6}+c \\] dan jika diimplementasikan menggunakan Python dengan bantuan library sympy akan seperti berikut: import sympy as sp x = sp.Symbol('x') sp.integrate(4*x**5, x) output yang dihasilkan seperti berikut: \\[ \\dfrac{2x^{6}}{3} \\] mari kita coba contoh lain seperti berikut: \\[ \\int \\left( 6x^{2}+4x-6\\right) dx=\\dfrac{6}{3}x^{3}+\\dfrac{4}{2}x^{2}-6x+c \\] pada contoh diatas dapat kita uraikan: \\(\\int 6x^{2} = \\dfrac{6}{3}x^{3}\\) \\(4x = 4x^{1}\\) , maka \\(\\int 4x = \\dfrac{4}{2}x^{2}\\) \\(6 = 6x^{0}\\) , maka \\(\\int 6x = \\dfrac{6}{1}x^{1} = 6x\\) hasil nya juga dapat kita sederhanakan menjadi: \\[ \\int \\left( 6x^{2}+4x-6\\right) dx = 2x^{3} + 2x^{2} - 6x \\] maka jika kita implementasikan pada python akan seperti berikut: import sympy as sp x = sp.Symbol('x') sp.integrate((6*x**2 + 4*x - 6), x) Referensi : Integrasi Numerik oleh Rinaldi Munir (IF-STEI ITB) Integrasi Numerik.ppt Integrasi Numerik - UNY 6.6.2 Metode Romberg","title":"Contoh"},{"location":"Integrasi%20Numerik/02_Klasifikasi%20Metode%20Integrasi%20Numerik/","text":"Klasifikasi Metode Integrasi Numerik Metode Newton-Cotes Rumus Newton-Cotes adalah keluarga teknik integrasi numerik yang sangat berguna dan mudah. Untuk mengintegrasikan fungsi \\(f(x)\\) selama beberapa interval \\([a, b]\\) , bagilah menjadi \\(n\\) bagian yang sama seperti \\(f_{n}=f\\left( x_{n}\\right)\\) dan \\(h=(b-a)/n\\) . Metode Romberg Metode Romberg adalah teknik integrasi numerik yang kuat yang menggunakan penyempurnaan aturan trapesium yang diperluas untuk mengurangi kesalahan dalam integral yang pasti. Metode Romberg menggabungkan Aturan Trapesium Komposit dengan Richardson Extrapolation. Kuadratur Gauss Properti penting dari kuadratur Gauss adalah bahwa ia menghasilkan nilai integral yang tepat untuk polinomial derajat hingga \\(2n - 1\\) . Kuadrat Gauss menggunakan nilai fungsi yang dievaluasi di sejumlah titik interior (karenanya itu adalah aturan kuadrat terbuka) dan bobot yang sesuai untuk memperkirakan integral dengan jumlah tertimbang.","title":"Klasifikasi Metode Integrasi Numerik"},{"location":"Integrasi%20Numerik/02_Klasifikasi%20Metode%20Integrasi%20Numerik/#klasifikasi-metode-integrasi-numerik","text":"","title":"Klasifikasi Metode Integrasi Numerik"},{"location":"Integrasi%20Numerik/02_Klasifikasi%20Metode%20Integrasi%20Numerik/#metode-newton-cotes","text":"Rumus Newton-Cotes adalah keluarga teknik integrasi numerik yang sangat berguna dan mudah. Untuk mengintegrasikan fungsi \\(f(x)\\) selama beberapa interval \\([a, b]\\) , bagilah menjadi \\(n\\) bagian yang sama seperti \\(f_{n}=f\\left( x_{n}\\right)\\) dan \\(h=(b-a)/n\\) .","title":"Metode Newton-Cotes"},{"location":"Integrasi%20Numerik/02_Klasifikasi%20Metode%20Integrasi%20Numerik/#metode-romberg","text":"Metode Romberg adalah teknik integrasi numerik yang kuat yang menggunakan penyempurnaan aturan trapesium yang diperluas untuk mengurangi kesalahan dalam integral yang pasti. Metode Romberg menggabungkan Aturan Trapesium Komposit dengan Richardson Extrapolation.","title":"Metode Romberg"},{"location":"Integrasi%20Numerik/02_Klasifikasi%20Metode%20Integrasi%20Numerik/#kuadratur-gauss","text":"Properti penting dari kuadratur Gauss adalah bahwa ia menghasilkan nilai integral yang tepat untuk polinomial derajat hingga \\(2n - 1\\) . Kuadrat Gauss menggunakan nilai fungsi yang dievaluasi di sejumlah titik interior (karenanya itu adalah aturan kuadrat terbuka) dan bobot yang sesuai untuk memperkirakan integral dengan jumlah tertimbang.","title":"Kuadratur Gauss"},{"location":"Integrasi%20Numerik/03_Newton-Cotes/","text":"Metode Newton-Cotes Dalam Metode Newton-Cotes, fungsi ini diperkirakan oleh polinomial dari urutan \\(n\\) . Untuk melakukan ini, kita dapat menggunakan ide-ide yang dipelajari dari interpolasi. Menghitung integral polinomial itu mudah. \\[ \\int ^{b}_{a}f\\left( x\\right) dx\\approx \\int ^{b}_{a}\\left( a_{0}+a_{1}x+\\ldots +a_{n}x^{n}\\right) dx \\] kita memperkirakan fungsi \\(f(x)\\) dalam interval \\([a,b]\\) sebagai: \\[ f\\left( x\\right) \\approx a_{0}+a_{1}\\times \\ldots +a_{n}x^{n} \\] interpolasi \\[ \\int ^{b}_{a}f\\left( x\\right) dx\\approx a_{0}\\left( b-a\\right) +a,\\dfrac{\\left( b^{2}-a^{2}\\right) }{2}+\\ldots +a_{n}\\dfrac{\\left( b^{n+1}-a^{n+1}\\right) }{n+1} \\] Metode Trapezoidal atau Trapesium Integral yang pasti dari \\(f(x)\\) sama dengan area di bawah kurva \\(y = f(x)\\) selama interval \\([a,b]\\) . Riemann menjumlahkan perkiraan integral yang pasti dengan menggunakan jumlah persegi panjang untuk memperkirakan area. Metode trapesium memberikan perkiraan yang lebih baik dari integral yang pasti dengan menjumlahkan area trapesium yang menghubungkan titik-titik \\[ \\left( x_{i-1},0\\right),\\left( x_{i},0\\right),\\left( x_{i-1},f\\left( x_{i-1}\\right) \\right),\\left( x_{i},f\\left( x_{i}\\right) \\right) \\] untuk setiap subinterval \\([x_{i-1}, x_{i}]\\) dari sebuah partisi. Perhatikan bahwa area setiap trapesium adalah jumlah persegi panjang dan segitiga \\[ \\left( x_{i}-x_{i-1}\\right) f\\left( x_{i-1}\\right) +\\dfrac{1}{2}\\left( x_{i}-x_{i-1}\\right)\\left( f\\left( x_{1}\\right) -f\\left( x_{i-1}\\right) \\right) =\\dfrac{1}{2}\\left( f\\left( x_{i}\\right) +f\\left( x_{i-1}\\right) \\right) \\left( x_{i}-x_{i-1}\\right) \\] Misalnya, kita dapat menggunakan trapesium tunggal untuk memperkirakan: \\[ \\int ^{1}_{0}e^{-x^{2}}dx \\] Disini kita akan menggunakan numpy untuk membantu perhitungan interval dan matplotlib untuk melakukan plotting. Pertama, mari kita plot kurva \\(y = e^{-x^{2}}\\) dan membuat trapesium pada interval \\([0,1]\\) : import numpy as np import matplotlib.pyplot as plt %matplotlib inline x = np.linspace(-0.5,1.5,100) y = np.exp(-x**2) plt.plot(x,y) x0 = 0; x1 = 1; y0 = np.exp(-x0**2); y1 = np.exp(-x1**2); plt.fill_between([x0,x1],[y0,y1]) plt.xlim([-0.5,1.5]); plt.ylim([0,1.5]); plt.show() Perkiraan integral pada area trapesium: A = 0.5 * (y1 + y0) * (x1 - x0) print(\"Trapezoid area:\", A) # Output # Trapezoid area: 0.6839397205857212 Definisi Aturan trapesium untuk subinterval \\(N\\) dari \\([a,b]\\) dengan panjang yang sama adalah \\[ T_N(f) = \\frac{\\Delta x}{2} \\sum_{i=1}^N (f(x_i) + f(x_{i-1})) \\] di mana \\(\\Delta x = (b - a)/N\\) adalah panjang subinterval dan \\(x_i = a + i \\Delta x\\) . Perhatikan bahwa trapesium adalah rata-rata dari jumlah Riemann kiri dan kanan \\[ T_N(f) = \\frac{\\Delta x}{2} \\sum_{i=1}^N (f(x_i) + f(x_{i-1})) = \\frac{1}{2} \\left( \\sum_{i=1}^N f(x_i) \\Delta x + \\sum_{i=1}^N f(x_{i-1}) \\Delta x \\right) \\] Rumus Kesalahan (Error Formula) Ketika komputasi integral secara numerik, penting untuk mengetahui seberapa baik perkiraan kita. Perhatikan dalam teorema di bawah ini bahwa rumus kesalahan berbanding terbalik dengan \\(N^2\\) . Ini berarti bahwa kesalahan menurun jauh lebih cepat dengan \\(N\\) yang lebih besar dibandingkan dengan Riemann sums. Teoremanya sebagai berikut: \\(T_N(f)\\) menunjukkan aturan trapesium \\[ T_N(f) = \\frac{\\Delta x}{2} \\sum_{i=1}^N (f(x_i) + f(x_{i-1})) \\] di mana \\(\\Delta x = (b-a)/N\\) dan \\(x_i = a + i \\Delta x\\) . Batas error-nya adalah \\[ E_N^T(f) = \\left| \\ \\int_a^b f(x) \\ dx - T_N(f) \\ \\right| \\leq \\frac{(b-a)^3}{12 N^2} K_2 \\] di mana \\(\\left| \\ f''(x) \\, \\right| \\leq K_2\\) untuk semua \\(x \\in [a,b]\\) . Implementasi Mari kita menulis fungsi yang disebut trapz yang mengambil parameter input \\(f,a,b\\) dan \\(N\\) dan mengembalikan perkiraan \\(T_N(f)\\) . Selain itu, mari kita tetapkan nilai default \\(N=50\\) . def trapz(f,a,b,N=50): ''' Perkiraan integral f(x) dari a ke b oleh aturan trapesium. Aturan trapesium memperkirakan integral int_a^b f(x) dx dengan jumlah: (dx/2) \\sum_{k=1}^N (f(x_k) + f(x_{k-1})) di mana x_k = a + k*dx dan dx = (b - a)/N. Parameters ---------- f : function Fungsi vektorisasi dari variabel tunggal a , b : numbers Interval integrasi [a,b] N : integer Jumlah subinterval [a,b] Returns ------- float Perkiraan integral f(x) dari a ke b menggunakan aturan trapesium dengan subinterval N dengan panjang yang sama. Contoh -------- >>> trapz(np.sin,0,np.pi/2,1000) 0.9999997943832332 ''' x = np.linspace(a,b,N+1) # N+1 poin membuat subinterval N y = f(x) y_right = y[1:] # titik akhir kanan y_left = y[:-1] # titik akhir kiri dx = (b - a)/N T = (dx/2) * np.sum(y_right + y_left) return T Mari kita uji fungsi kita pada integral di mana kita tahu jawabannya \\[ \\int_0^{\\pi/2} \\sin x \\ dx = 1 \\] trapz(np.sin,0,np.pi/2,1000) # Output: 0.9999997943832332 Mari kita uji fungsi kita lagi: \\[ \\int_0^1 3 x^2 \\ dx = 1 \\] trapz(lambda x : 3*x**2,0,1,10000) # Output: 1.0000000050000002 Dan sekali lagi: \\[ \\int_0^1 x \\ dx = \\frac{1}{2} \\] trapz(lambda x : x,0,1,1) # Output: 0.5 Aturan Simpson import numpy as np import matplotlib.pyplot as plt %matplotlib inline Definisi Aturan Simpson menggunakan polinomial kuadrat pada setiap subinterval partisi untuk memperkirakan fungsi \\(f(x)\\) dan untuk menghitung integral yang pasti. Ini adalah perbaikan atas aturan trapesium yang memperkirakan \\(f(x)\\) oleh garis lurus pada setiap subinterval partisi. Rumus untuk aturan Simpson adalah sebagai berikut \\[ S_N(f) = \\frac{\\Delta x}{3} \\sum_{i=1}^{N/2} \\left( f(x_{2i-2}) + 4 f(x_{2i-1}) + f(x_{2i}) \\right) \\] di mana \\(N\\) adalah jumlah subinterval \\([a,b]\\) , \\(\\Delta x = (b - a)/N\\) dan \\(x_i = a + i \\Delta x\\) . Rumus Kesalahan Kami telah melihat bahwa kesalahan dalam jumlah Riemann berbanding terbalik dengan ukuran partisi \\(N\\) dan aturan trapesium berbanding terbalik dengan \\(N^2\\) . Rumus kesalahan dalam teorema di bawah ini menunjukkan bahwa aturan Simpson bahkan lebih baik karena kesalahan berbanding terbalik dengan \\(N^4\\) . \\(S_N(f)\\) menunjukkan aturan Simpson \\[ S_N(f) = \\frac{\\Delta x}{3} \\sum_{i=1}^{N/2} \\left( f(x_{2i-2}) + 4 f(x_{2i-1}) + f(x_{2i}) \\right) \\] di mana \\(N\\) adalah jumlah subinterval \\([a,b]\\) , \\(\\Delta x = (b - a)/N\\) dan \\(x_i = a + i \\Delta x\\) . Batas kesalahan adalah \\[ E_N^S(f) = \\left| \\ \\int_a^b f(x) \\, dx - S_N(f) \\ \\right| \\leq \\frac{(b-a)^5}{180N^4} K_4 \\] di mana \\(\\left| \\ f^{(4)}(x) \\ \\right| \\leq K_4\\) untuk semua \\(x \\in [a,b]\\) . Implementasi Mari kita tulis fungsi yang disebut simps yang mengambil parameter input \\(f\\) , \\(a\\) , \\(b\\) dan \\(N\\) dan mengembalikan perkiraan \\(S_N(f)\\) . Selain itu, mari kita tetapkan nilai default \\(N = 50\\) . def simps(f,a,b,N=50): '''Perkiraan integral f(x) dari a ke b dengan aturan Simpson. Aturan Simpson memperkirakan integral int_a^b f(x) dx dengan jumlah: (dx/3) \\sum_{k=1}^{N/2} (f(x_{2i-2} + 4f(x_{2i-1}) + f(x_{2i})) dimana x_i = a + i*dx dan dx = (b - a)/N. Parameters ---------- f : function Fungsi vektorisasi dari variabel tunggal a , b : numbers Interval integrasi [a,b] N : (even) integer Jumlah subinterval [a,b] Returns ------- float Perkiraan integral f(x) dari a ke b menggunakan aturan Simpson dengan subinterval N dengan panjang yang sama. Contoh -------- >>> simps(lambda x : 3*x**2,0,1,10) 1.0 ''' if N % 2 == 1: raise ValueError(\"N harus berupa bilangan bulat.\") dx = (b-a)/N x = np.linspace(a,b,N+1) y = f(x) S = dx/3 * np.sum(y[0:-1:2] + 4*y[1::2] + y[2::2]) return S Mari kita uji fungsi kita pada integral yang kita ketahui nilai pastinya. Misalnya, kita tahu \\[ \\int_0^1 3x^2 dx = 1 \\] simps(lambda x : 3*x**2,0,1,10) # Output: 1.0 Uji lagi fungsi kita dengan integral \\[ \\int_0^{\\pi/2} \\sin(x) dx = 1 \\] simps(np.sin,0,np.pi/2,100) # Output: 1.000000000338236","title":"Metode Newton-Cotes"},{"location":"Integrasi%20Numerik/03_Newton-Cotes/#metode-newton-cotes","text":"Dalam Metode Newton-Cotes, fungsi ini diperkirakan oleh polinomial dari urutan \\(n\\) . Untuk melakukan ini, kita dapat menggunakan ide-ide yang dipelajari dari interpolasi. Menghitung integral polinomial itu mudah. \\[ \\int ^{b}_{a}f\\left( x\\right) dx\\approx \\int ^{b}_{a}\\left( a_{0}+a_{1}x+\\ldots +a_{n}x^{n}\\right) dx \\] kita memperkirakan fungsi \\(f(x)\\) dalam interval \\([a,b]\\) sebagai: \\[ f\\left( x\\right) \\approx a_{0}+a_{1}\\times \\ldots +a_{n}x^{n} \\] interpolasi \\[ \\int ^{b}_{a}f\\left( x\\right) dx\\approx a_{0}\\left( b-a\\right) +a,\\dfrac{\\left( b^{2}-a^{2}\\right) }{2}+\\ldots +a_{n}\\dfrac{\\left( b^{n+1}-a^{n+1}\\right) }{n+1} \\]","title":"Metode Newton-Cotes"},{"location":"Integrasi%20Numerik/03_Newton-Cotes/#metode-trapezoidal-atau-trapesium","text":"Integral yang pasti dari \\(f(x)\\) sama dengan area di bawah kurva \\(y = f(x)\\) selama interval \\([a,b]\\) . Riemann menjumlahkan perkiraan integral yang pasti dengan menggunakan jumlah persegi panjang untuk memperkirakan area. Metode trapesium memberikan perkiraan yang lebih baik dari integral yang pasti dengan menjumlahkan area trapesium yang menghubungkan titik-titik \\[ \\left( x_{i-1},0\\right),\\left( x_{i},0\\right),\\left( x_{i-1},f\\left( x_{i-1}\\right) \\right),\\left( x_{i},f\\left( x_{i}\\right) \\right) \\] untuk setiap subinterval \\([x_{i-1}, x_{i}]\\) dari sebuah partisi. Perhatikan bahwa area setiap trapesium adalah jumlah persegi panjang dan segitiga \\[ \\left( x_{i}-x_{i-1}\\right) f\\left( x_{i-1}\\right) +\\dfrac{1}{2}\\left( x_{i}-x_{i-1}\\right)\\left( f\\left( x_{1}\\right) -f\\left( x_{i-1}\\right) \\right) =\\dfrac{1}{2}\\left( f\\left( x_{i}\\right) +f\\left( x_{i-1}\\right) \\right) \\left( x_{i}-x_{i-1}\\right) \\] Misalnya, kita dapat menggunakan trapesium tunggal untuk memperkirakan: \\[ \\int ^{1}_{0}e^{-x^{2}}dx \\] Disini kita akan menggunakan numpy untuk membantu perhitungan interval dan matplotlib untuk melakukan plotting. Pertama, mari kita plot kurva \\(y = e^{-x^{2}}\\) dan membuat trapesium pada interval \\([0,1]\\) : import numpy as np import matplotlib.pyplot as plt %matplotlib inline x = np.linspace(-0.5,1.5,100) y = np.exp(-x**2) plt.plot(x,y) x0 = 0; x1 = 1; y0 = np.exp(-x0**2); y1 = np.exp(-x1**2); plt.fill_between([x0,x1],[y0,y1]) plt.xlim([-0.5,1.5]); plt.ylim([0,1.5]); plt.show() Perkiraan integral pada area trapesium: A = 0.5 * (y1 + y0) * (x1 - x0) print(\"Trapezoid area:\", A) # Output # Trapezoid area: 0.6839397205857212","title":"Metode Trapezoidal atau Trapesium"},{"location":"Integrasi%20Numerik/03_Newton-Cotes/#definisi","text":"Aturan trapesium untuk subinterval \\(N\\) dari \\([a,b]\\) dengan panjang yang sama adalah \\[ T_N(f) = \\frac{\\Delta x}{2} \\sum_{i=1}^N (f(x_i) + f(x_{i-1})) \\] di mana \\(\\Delta x = (b - a)/N\\) adalah panjang subinterval dan \\(x_i = a + i \\Delta x\\) . Perhatikan bahwa trapesium adalah rata-rata dari jumlah Riemann kiri dan kanan \\[ T_N(f) = \\frac{\\Delta x}{2} \\sum_{i=1}^N (f(x_i) + f(x_{i-1})) = \\frac{1}{2} \\left( \\sum_{i=1}^N f(x_i) \\Delta x + \\sum_{i=1}^N f(x_{i-1}) \\Delta x \\right) \\]","title":"Definisi"},{"location":"Integrasi%20Numerik/03_Newton-Cotes/#rumus-kesalahan-error-formula","text":"Ketika komputasi integral secara numerik, penting untuk mengetahui seberapa baik perkiraan kita. Perhatikan dalam teorema di bawah ini bahwa rumus kesalahan berbanding terbalik dengan \\(N^2\\) . Ini berarti bahwa kesalahan menurun jauh lebih cepat dengan \\(N\\) yang lebih besar dibandingkan dengan Riemann sums. Teoremanya sebagai berikut: \\(T_N(f)\\) menunjukkan aturan trapesium \\[ T_N(f) = \\frac{\\Delta x}{2} \\sum_{i=1}^N (f(x_i) + f(x_{i-1})) \\] di mana \\(\\Delta x = (b-a)/N\\) dan \\(x_i = a + i \\Delta x\\) . Batas error-nya adalah \\[ E_N^T(f) = \\left| \\ \\int_a^b f(x) \\ dx - T_N(f) \\ \\right| \\leq \\frac{(b-a)^3}{12 N^2} K_2 \\] di mana \\(\\left| \\ f''(x) \\, \\right| \\leq K_2\\) untuk semua \\(x \\in [a,b]\\) .","title":"Rumus Kesalahan (Error Formula)"},{"location":"Integrasi%20Numerik/03_Newton-Cotes/#implementasi","text":"Mari kita menulis fungsi yang disebut trapz yang mengambil parameter input \\(f,a,b\\) dan \\(N\\) dan mengembalikan perkiraan \\(T_N(f)\\) . Selain itu, mari kita tetapkan nilai default \\(N=50\\) . def trapz(f,a,b,N=50): ''' Perkiraan integral f(x) dari a ke b oleh aturan trapesium. Aturan trapesium memperkirakan integral int_a^b f(x) dx dengan jumlah: (dx/2) \\sum_{k=1}^N (f(x_k) + f(x_{k-1})) di mana x_k = a + k*dx dan dx = (b - a)/N. Parameters ---------- f : function Fungsi vektorisasi dari variabel tunggal a , b : numbers Interval integrasi [a,b] N : integer Jumlah subinterval [a,b] Returns ------- float Perkiraan integral f(x) dari a ke b menggunakan aturan trapesium dengan subinterval N dengan panjang yang sama. Contoh -------- >>> trapz(np.sin,0,np.pi/2,1000) 0.9999997943832332 ''' x = np.linspace(a,b,N+1) # N+1 poin membuat subinterval N y = f(x) y_right = y[1:] # titik akhir kanan y_left = y[:-1] # titik akhir kiri dx = (b - a)/N T = (dx/2) * np.sum(y_right + y_left) return T Mari kita uji fungsi kita pada integral di mana kita tahu jawabannya \\[ \\int_0^{\\pi/2} \\sin x \\ dx = 1 \\] trapz(np.sin,0,np.pi/2,1000) # Output: 0.9999997943832332 Mari kita uji fungsi kita lagi: \\[ \\int_0^1 3 x^2 \\ dx = 1 \\] trapz(lambda x : 3*x**2,0,1,10000) # Output: 1.0000000050000002 Dan sekali lagi: \\[ \\int_0^1 x \\ dx = \\frac{1}{2} \\] trapz(lambda x : x,0,1,1) # Output: 0.5","title":"Implementasi"},{"location":"Integrasi%20Numerik/03_Newton-Cotes/#aturan-simpson","text":"import numpy as np import matplotlib.pyplot as plt %matplotlib inline","title":"Aturan Simpson"},{"location":"Integrasi%20Numerik/03_Newton-Cotes/#definisi_1","text":"Aturan Simpson menggunakan polinomial kuadrat pada setiap subinterval partisi untuk memperkirakan fungsi \\(f(x)\\) dan untuk menghitung integral yang pasti. Ini adalah perbaikan atas aturan trapesium yang memperkirakan \\(f(x)\\) oleh garis lurus pada setiap subinterval partisi. Rumus untuk aturan Simpson adalah sebagai berikut \\[ S_N(f) = \\frac{\\Delta x}{3} \\sum_{i=1}^{N/2} \\left( f(x_{2i-2}) + 4 f(x_{2i-1}) + f(x_{2i}) \\right) \\] di mana \\(N\\) adalah jumlah subinterval \\([a,b]\\) , \\(\\Delta x = (b - a)/N\\) dan \\(x_i = a + i \\Delta x\\) .","title":"Definisi"},{"location":"Integrasi%20Numerik/03_Newton-Cotes/#rumus-kesalahan","text":"Kami telah melihat bahwa kesalahan dalam jumlah Riemann berbanding terbalik dengan ukuran partisi \\(N\\) dan aturan trapesium berbanding terbalik dengan \\(N^2\\) . Rumus kesalahan dalam teorema di bawah ini menunjukkan bahwa aturan Simpson bahkan lebih baik karena kesalahan berbanding terbalik dengan \\(N^4\\) . \\(S_N(f)\\) menunjukkan aturan Simpson \\[ S_N(f) = \\frac{\\Delta x}{3} \\sum_{i=1}^{N/2} \\left( f(x_{2i-2}) + 4 f(x_{2i-1}) + f(x_{2i}) \\right) \\] di mana \\(N\\) adalah jumlah subinterval \\([a,b]\\) , \\(\\Delta x = (b - a)/N\\) dan \\(x_i = a + i \\Delta x\\) . Batas kesalahan adalah \\[ E_N^S(f) = \\left| \\ \\int_a^b f(x) \\, dx - S_N(f) \\ \\right| \\leq \\frac{(b-a)^5}{180N^4} K_4 \\] di mana \\(\\left| \\ f^{(4)}(x) \\ \\right| \\leq K_4\\) untuk semua \\(x \\in [a,b]\\) .","title":"Rumus Kesalahan"},{"location":"Integrasi%20Numerik/03_Newton-Cotes/#implementasi_1","text":"Mari kita tulis fungsi yang disebut simps yang mengambil parameter input \\(f\\) , \\(a\\) , \\(b\\) dan \\(N\\) dan mengembalikan perkiraan \\(S_N(f)\\) . Selain itu, mari kita tetapkan nilai default \\(N = 50\\) . def simps(f,a,b,N=50): '''Perkiraan integral f(x) dari a ke b dengan aturan Simpson. Aturan Simpson memperkirakan integral int_a^b f(x) dx dengan jumlah: (dx/3) \\sum_{k=1}^{N/2} (f(x_{2i-2} + 4f(x_{2i-1}) + f(x_{2i})) dimana x_i = a + i*dx dan dx = (b - a)/N. Parameters ---------- f : function Fungsi vektorisasi dari variabel tunggal a , b : numbers Interval integrasi [a,b] N : (even) integer Jumlah subinterval [a,b] Returns ------- float Perkiraan integral f(x) dari a ke b menggunakan aturan Simpson dengan subinterval N dengan panjang yang sama. Contoh -------- >>> simps(lambda x : 3*x**2,0,1,10) 1.0 ''' if N % 2 == 1: raise ValueError(\"N harus berupa bilangan bulat.\") dx = (b-a)/N x = np.linspace(a,b,N+1) y = f(x) S = dx/3 * np.sum(y[0:-1:2] + 4*y[1::2] + y[2::2]) return S Mari kita uji fungsi kita pada integral yang kita ketahui nilai pastinya. Misalnya, kita tahu \\[ \\int_0^1 3x^2 dx = 1 \\] simps(lambda x : 3*x**2,0,1,10) # Output: 1.0 Uji lagi fungsi kita dengan integral \\[ \\int_0^{\\pi/2} \\sin(x) dx = 1 \\] simps(np.sin,0,np.pi/2,100) # Output: 1.000000000338236","title":"Implementasi"},{"location":"Integrasi%20Numerik/04_Romberd/","text":"Metode Romberg Definisi Ekstrapolasi Richardson tidak hanya digunakan untuk menghitung perkiraan derivatif yang lebih akurat, tetapi juga digunakan sebagai fondasi skema integrasi numerik yang disebut integrasi Romberg atau metode Romberg. di skema ini, \\[ I\\left( f\\right) =\\int ^{b}_{a}f\\left( x\\right) dx \\] diperkirakan menggunakan Aturan Trapesium Komposit dengan ukuran langkah \\(h_{k}=\\left( b-a\\right) 2^{-k}\\) , di mana \\(k\\) adalah bilangan bulat absolut. Kemudian, untuk setiap \\(k\\) , ekstrapolasi Richardson digunakan \\(k\u22121\\) kali untuk perkiraan yang sebelumnya dihitung untuk meningkatkan urutan akurasi sebanyak mungkin. Lebih tepatnya, misalkan kita menghitung perkiraan T1,1 dan T2,1 ke integral, menggunakan Aturan Trapesium Komposit dengan masing-masing satu dan dua subinterval. Yaitu \\[ T_{1,1}=\\dfrac{b-a}{2}\\left[ f\\left( a\\right) +f( b\\right] \\] \\[ T_{2,1}=\\dfrac{b-a}{4}\\left[ f\\left( a\\right) +2f\\left( \\dfrac{a+b}{2}\\right) +f\\left( b\\right) \\right] \\] Misalkan \\(f\\) memiliki turunan berkelanjutan dari semua pesanan pada \\([a,b]\\) . Kemudian, Trapesium Komposit Aturan, untuk jumlah umum subinterval \\(n\\) , memenuhi \\[ \\int ^{b}_{a}f\\left( x\\right) dx=\\dfrac{h}{2}\\left[ f\\left( a\\right) +2\\sum ^{n-1}_{j=1}f\\left( x_{j}\\right) +f\\left( b\\right) \\right]+\\sum ^{\\infty }_{i=1}K_{i}h^{2i} \\] di mana \\(h=\\left( b-a\\right) /n,x_{j}=a+jh\\) , dan konstanta \\(\\left\\{ K_{i}\\right\\} _{i=1}^{\\infty }\\) hanya bergantung pada turunan dari \\(f\\) . Ini memberitahu bahwa kita dapat menggunakan Ekstrapolasi Richardson untuk menghitung perkiraan dengan urutan akurasi yang lebih tinggi. Jika kita menunjukkan nilai pasti dari integral oleh \\(I(f)\\) maka kita mendapatkan \\[ T_{1,1}=I\\left( f\\right) +K_{1}h^{2}+O\\left( h^{4}\\right) \\] \\[ T_{2i}=I\\left( f\\right) +K_{1}\\left( h/2\\right) ^{2}+O\\left( h^{4}\\right) \\] Mengabaikan istilah \\(O\\left( h^{4}\\right)\\) , kita memiliki sistem persamaan yang dapat kita pecahkan untuk \\(K_{1}\\) dan \\(I\\left( f\\right)\\) . Nilai \\(I\\left( f\\right)\\) , yang diuraikan oleh \\(T_{2,2}\\) , adalah perkiraan yang ditingkatkan yang didapat dari \\[ T_{2,2}=T_{21},\\dfrac{T_{2,1}-T_{1,1}}{3} \\] Ini mengikuti dari representasi kesalahan dalam Aturan Trapesium Komposit bahwa \\(I\\left( f\\right) =T_{2,2}+O\\left( h^{4}\\right)\\) . Misalkan kita menghitung perkiraan lain \\(T_{3,1}\\) menggunakan Aturan Trapesium Komposit dengan 4 subinterval. Kemudian, seperti sebelumnya, kita dapat menggunakan Ekstrapolasi Richardson dengan \\(T_{2,1}\\) dan \\(T_{3,1}\\) untuk mendapatkan perkiraan baru \\(T_{3,2}\\) yang akurat urutan keempat. Sekarang, kita memiliki dua perkiraan, \\(T_{2,2}\\) dan \\(T_{3,2}\\) yang memuaskan \\[ T_{2,2}=I\\left( f\\right) +\\overline{K}_{2}h^{4}+O\\left( h^{6}\\right) \\] \\[ T_{3,2}=I\\left( f\\right) +\\overline{K}_{2}\\left( h/2\\right) ^{4}+O\\left( h^{6}\\right) \\] untuk beberapa konstan \\(\\overline{K}_{2}\\) . Ini mengikuti bahwa kita dapat menerapkan Ekstrapolasi Richardson untuk perkiraan ini untuk mendapatkan perkiraan baru \\(T_{3,3}\\) yang akurat urutan keenam. Kita dapat melanjutkan proses ini untuk mendapatkan urutan akurasi setinggi yang kita inginkan. Kita sekarang menggambarkan seluruh algoritmanya. Algoritma Algoritma (Metode Romberg) Diberikan bilangan bulat positif \\(J\\) , interval \\([a,b]\\) dan fungsi \\(f(x)\\) , algoritma berikut menghitung perkiraan untuk \\(I\\left( f\\right) =\\int ^{b}_{a}f\\left( x\\right) dx\\) yang akurat untuk memesan \\(2J\\) . \\(h = b - a\\) for \\(j = 1, 2, ... , J\\) do \\(T_{j,1}=\\dfrac{h}{2}\\left[ f\\left( a\\right) +2\\sum ^{2^{j-1}-1}_{j=1}f\\left( a+jh\\right) +f\\left( b\\right) \\right]\\) (Aturan Trapesium Komposit) for \\(k = 2,3,...,j\\) do \\(T_{j,k}=T_{j,k-1}+\\dfrac{T_{1,k-1}-T_{j-1,k-1}}{4^{k-1}-1}\\) (Ekstrapolasi Richardson) end \\(h = h / 2\\) end Implementasi import numpy as np import matplotlib.pyplot as plt def f1(x): f1 = x**4.0 return f1; def f2(x): f2 = np.exp(-x*x) return f2; def f3(x): tau = 1.0e-8 f3 = np.where(np.abs(x)<tau,1.0,np.sin(x)/x) return f3; # trapezoidal rule def trapezoid(f,a,b,N): h = (b-a)/N xi = np.linspace(a,b,N+1) fi = f(xi) s = 0.0 for i in range(1,N): s = s + fi[i] s = (h/2)*(fi[0] + fi[N]) + h*s return s # romberg method def romberg(f,a,b,eps,nmax): # f ... fungsi untuk diintegrasikan # [a,b] ... interval integrasi # eps ... akurasi yang diinginkan # nmax ... urutan maksimal metode Romberg Q = np.zeros((nmax,nmax),float) converged = 0 for i in range(0,nmax): N = 2**i Q[i,0] = trapezoid(f,a,b,N) for k in range(0,i): n = k + 2 Q[i,k+1] = 1.0/(4**(n-1)-1)*(4**(n-1)*Q[i,k] - Q[i-1,k]) if (i > 0): if (abs(Q[i,k+1] - Q[i,k]) < eps): converged = 1 break print Q[i,k+1],N,converged return Q[i,k+1],N,converged # main program a = 0.0;b = 1.0 # interval integrasi [a,b] romberg(f1,a,b,1.0e-12,10) romberg(f2,a,b,1.0e-12,10) a = 0.0;b = 20.0*np.pi # interval integrasi [a,b] romberg(f3,a,b,1.0e-12,10)","title":"Metode Romberg"},{"location":"Integrasi%20Numerik/04_Romberd/#metode-romberg","text":"","title":"Metode Romberg"},{"location":"Integrasi%20Numerik/04_Romberd/#definisi","text":"Ekstrapolasi Richardson tidak hanya digunakan untuk menghitung perkiraan derivatif yang lebih akurat, tetapi juga digunakan sebagai fondasi skema integrasi numerik yang disebut integrasi Romberg atau metode Romberg. di skema ini, \\[ I\\left( f\\right) =\\int ^{b}_{a}f\\left( x\\right) dx \\] diperkirakan menggunakan Aturan Trapesium Komposit dengan ukuran langkah \\(h_{k}=\\left( b-a\\right) 2^{-k}\\) , di mana \\(k\\) adalah bilangan bulat absolut. Kemudian, untuk setiap \\(k\\) , ekstrapolasi Richardson digunakan \\(k\u22121\\) kali untuk perkiraan yang sebelumnya dihitung untuk meningkatkan urutan akurasi sebanyak mungkin. Lebih tepatnya, misalkan kita menghitung perkiraan T1,1 dan T2,1 ke integral, menggunakan Aturan Trapesium Komposit dengan masing-masing satu dan dua subinterval. Yaitu \\[ T_{1,1}=\\dfrac{b-a}{2}\\left[ f\\left( a\\right) +f( b\\right] \\] \\[ T_{2,1}=\\dfrac{b-a}{4}\\left[ f\\left( a\\right) +2f\\left( \\dfrac{a+b}{2}\\right) +f\\left( b\\right) \\right] \\] Misalkan \\(f\\) memiliki turunan berkelanjutan dari semua pesanan pada \\([a,b]\\) . Kemudian, Trapesium Komposit Aturan, untuk jumlah umum subinterval \\(n\\) , memenuhi \\[ \\int ^{b}_{a}f\\left( x\\right) dx=\\dfrac{h}{2}\\left[ f\\left( a\\right) +2\\sum ^{n-1}_{j=1}f\\left( x_{j}\\right) +f\\left( b\\right) \\right]+\\sum ^{\\infty }_{i=1}K_{i}h^{2i} \\] di mana \\(h=\\left( b-a\\right) /n,x_{j}=a+jh\\) , dan konstanta \\(\\left\\{ K_{i}\\right\\} _{i=1}^{\\infty }\\) hanya bergantung pada turunan dari \\(f\\) . Ini memberitahu bahwa kita dapat menggunakan Ekstrapolasi Richardson untuk menghitung perkiraan dengan urutan akurasi yang lebih tinggi. Jika kita menunjukkan nilai pasti dari integral oleh \\(I(f)\\) maka kita mendapatkan \\[ T_{1,1}=I\\left( f\\right) +K_{1}h^{2}+O\\left( h^{4}\\right) \\] \\[ T_{2i}=I\\left( f\\right) +K_{1}\\left( h/2\\right) ^{2}+O\\left( h^{4}\\right) \\] Mengabaikan istilah \\(O\\left( h^{4}\\right)\\) , kita memiliki sistem persamaan yang dapat kita pecahkan untuk \\(K_{1}\\) dan \\(I\\left( f\\right)\\) . Nilai \\(I\\left( f\\right)\\) , yang diuraikan oleh \\(T_{2,2}\\) , adalah perkiraan yang ditingkatkan yang didapat dari \\[ T_{2,2}=T_{21},\\dfrac{T_{2,1}-T_{1,1}}{3} \\] Ini mengikuti dari representasi kesalahan dalam Aturan Trapesium Komposit bahwa \\(I\\left( f\\right) =T_{2,2}+O\\left( h^{4}\\right)\\) . Misalkan kita menghitung perkiraan lain \\(T_{3,1}\\) menggunakan Aturan Trapesium Komposit dengan 4 subinterval. Kemudian, seperti sebelumnya, kita dapat menggunakan Ekstrapolasi Richardson dengan \\(T_{2,1}\\) dan \\(T_{3,1}\\) untuk mendapatkan perkiraan baru \\(T_{3,2}\\) yang akurat urutan keempat. Sekarang, kita memiliki dua perkiraan, \\(T_{2,2}\\) dan \\(T_{3,2}\\) yang memuaskan \\[ T_{2,2}=I\\left( f\\right) +\\overline{K}_{2}h^{4}+O\\left( h^{6}\\right) \\] \\[ T_{3,2}=I\\left( f\\right) +\\overline{K}_{2}\\left( h/2\\right) ^{4}+O\\left( h^{6}\\right) \\] untuk beberapa konstan \\(\\overline{K}_{2}\\) . Ini mengikuti bahwa kita dapat menerapkan Ekstrapolasi Richardson untuk perkiraan ini untuk mendapatkan perkiraan baru \\(T_{3,3}\\) yang akurat urutan keenam. Kita dapat melanjutkan proses ini untuk mendapatkan urutan akurasi setinggi yang kita inginkan. Kita sekarang menggambarkan seluruh algoritmanya.","title":"Definisi"},{"location":"Integrasi%20Numerik/04_Romberd/#algoritma","text":"Algoritma (Metode Romberg) Diberikan bilangan bulat positif \\(J\\) , interval \\([a,b]\\) dan fungsi \\(f(x)\\) , algoritma berikut menghitung perkiraan untuk \\(I\\left( f\\right) =\\int ^{b}_{a}f\\left( x\\right) dx\\) yang akurat untuk memesan \\(2J\\) . \\(h = b - a\\) for \\(j = 1, 2, ... , J\\) do \\(T_{j,1}=\\dfrac{h}{2}\\left[ f\\left( a\\right) +2\\sum ^{2^{j-1}-1}_{j=1}f\\left( a+jh\\right) +f\\left( b\\right) \\right]\\) (Aturan Trapesium Komposit) for \\(k = 2,3,...,j\\) do \\(T_{j,k}=T_{j,k-1}+\\dfrac{T_{1,k-1}-T_{j-1,k-1}}{4^{k-1}-1}\\) (Ekstrapolasi Richardson) end \\(h = h / 2\\) end","title":"Algoritma"},{"location":"Integrasi%20Numerik/04_Romberd/#implementasi","text":"import numpy as np import matplotlib.pyplot as plt def f1(x): f1 = x**4.0 return f1; def f2(x): f2 = np.exp(-x*x) return f2; def f3(x): tau = 1.0e-8 f3 = np.where(np.abs(x)<tau,1.0,np.sin(x)/x) return f3; # trapezoidal rule def trapezoid(f,a,b,N): h = (b-a)/N xi = np.linspace(a,b,N+1) fi = f(xi) s = 0.0 for i in range(1,N): s = s + fi[i] s = (h/2)*(fi[0] + fi[N]) + h*s return s # romberg method def romberg(f,a,b,eps,nmax): # f ... fungsi untuk diintegrasikan # [a,b] ... interval integrasi # eps ... akurasi yang diinginkan # nmax ... urutan maksimal metode Romberg Q = np.zeros((nmax,nmax),float) converged = 0 for i in range(0,nmax): N = 2**i Q[i,0] = trapezoid(f,a,b,N) for k in range(0,i): n = k + 2 Q[i,k+1] = 1.0/(4**(n-1)-1)*(4**(n-1)*Q[i,k] - Q[i-1,k]) if (i > 0): if (abs(Q[i,k+1] - Q[i,k]) < eps): converged = 1 break print Q[i,k+1],N,converged return Q[i,k+1],N,converged # main program a = 0.0;b = 1.0 # interval integrasi [a,b] romberg(f1,a,b,1.0e-12,10) romberg(f2,a,b,1.0e-12,10) a = 0.0;b = 20.0*np.pi # interval integrasi [a,b] romberg(f3,a,b,1.0e-12,10)","title":"Implementasi"},{"location":"Persamaan%20Diferensial/01_Pengantar/","text":"Pengantar Persamaan diferensial adalah persamaan yang melibatkan fungsi dan turunannya. Dengan kata lain, persamaan diferensial membuat pernyataan yang menghubungkan nilai kuantitas dengan tingkat perubahan kuantitas tersebut. Misalnya, untuk peluncuran roket, persamaan dapat ditulis menghubungkan kecepatannya ke posisinya, dan karena kecepatan adalah tingkat di mana posisi berubah, ini adalah persamaan diferensial. Memecahkan persamaan diferensial ini untuk posisi dalam hal waktu memungkinkan lokasi roket ditentukan kapan saja. Referensi : Pengertian dan Persamaan Diferensial Orde Satu - Youtube ITB Persamaan Diferensial - Universitas Gunadarma Persamaan Diferensial Tingkat Satu - Share ITS","title":"Pengantar"},{"location":"Persamaan%20Diferensial/01_Pengantar/#pengantar","text":"Persamaan diferensial adalah persamaan yang melibatkan fungsi dan turunannya. Dengan kata lain, persamaan diferensial membuat pernyataan yang menghubungkan nilai kuantitas dengan tingkat perubahan kuantitas tersebut. Misalnya, untuk peluncuran roket, persamaan dapat ditulis menghubungkan kecepatannya ke posisinya, dan karena kecepatan adalah tingkat di mana posisi berubah, ini adalah persamaan diferensial. Memecahkan persamaan diferensial ini untuk posisi dalam hal waktu memungkinkan lokasi roket ditentukan kapan saja. Referensi : Pengertian dan Persamaan Diferensial Orde Satu - Youtube ITB Persamaan Diferensial - Universitas Gunadarma Persamaan Diferensial Tingkat Satu - Share ITS","title":"Pengantar"},{"location":"Persamaan%20Diferensial/02_Persamaan%20Urutan%20Pertama/","text":"Persamaan Urutan Pertama Disini kita akan menggunakan numpy dan matplotlib, maka sebelum kita mulai, mari kita import kedua package tersebut: import numpy as np import matplotlib.pyplot as plt Definisi Persamaan diferensial adalah persamaan yang melibatkan fungsi \\(y(t)\\) yang tidak diketahui (dengan variabel independen \\(t\\) ) dan turunannya \\(y'\\) , \\(y''\\) , \\(y'''\\) , dll. Urutan persamaan diferensial mengacu pada turunan urutan tertinggi dari fungsi \\(y(t)\\) yang tidak diketahui muncul dalam persamaan. Persamaan diferensial berjajar jika bentuknya \\[ a_n(t) y^{(n)} + a_{n_1}(t) y^{(n-1)} + \\cdots + a_1(t) y' + a_0(t) y_0 = f(t) \\] di mana \\(a_n, \\dots, a_0, f\\) adalah fungsi dari variabel independen \\(t\\) saja. Misalnya, persamaan \\[ y'' + ty' + y^2 = t \\] adalah urutan kedua non-linear, dan persamaan \\[ y' + ty = t^2 \\] adalah linear urutan pertama. Sebagian besar persamaan diferensial tidak mungkin dipecahkan secara eksplisit namun kita selalu dapat menggunakan metode numerik untuk solusi perkiraan. Metode Euler Metode numerik paling sederhana untuk mendekati solusi persamaan diferensial adalah metode Euler. Pertimbangkan persamaan diferensial urutan pertama dengan kondisi awal: \\[ y' = f(y,y) \\ , \\ \\ y(t_0)=y_0 \\] Prosedur untuk metode Euler adalah sebagai berikut: Buat persamaan garis tangen ke fungsi \\(y(t)\\) yang tidak diketahui di \\(t=t_0\\) : \\[ y = y(t_0) + f(y_0,t_0)(t - t_0) \\] di mana \\(y'(t_0) = f(y_0,t_0)\\) adalah kemiringan \\(y(t)\\) di \\(t=t_0\\) . Gunakan garis tangen untuk memperkirakan \\(y(t)\\) pada langkah kecil \\(t_1 = t_0 + h\\) . \\[ y_1 = y_0 + f(y_0,t_0)(t_1 - t_0) \\] di mana \\(y_1 \\approx y(t_1)\\) . Bangun garis tangen pada titik \\((t_1,y_1)\\) dan ulangi. Rumus untuk metode Euler menentukan urutan rekursif: \\[ y_{n+1} = y_n + f(y_n,t_n)(t_{n+1} - t_n) \\ , \\ \\ y_0 = y(t_0) \\] di mana \\(y_n \\approx y(t_n)\\) untuk setiap \\(n\\) . Jika kita memilih nilai \\(t\\) ber spasi yang sama maka rumus menjadi \\[ y_{n+1} = y_n + f(y_n,t_n)h \\ \\ , \\ \\ y_0 = y(t_0) \\ , \\ \\ t_n = t_0 + nh \\] dengan langkah waktu \\(h = t_{n+1} - t_n\\) . Perhatikan dua hal yang sangat penting tentang metode Euler dan metode numerik secara umum: Langkah waktu yang lebih kecil \\(h\\) mengurangi kesalahan dalam perkiraan. Langkah waktu yang lebih kecil \\(h\\) membutuhkan lebih banyak komputasi. Implementasi Mari kita tulis fungsi yang disebut odeEuler yang mengambil 3 parameter input f, y0, dan t di mana: f adalah fungsi dari 2 variabel yang mewakili sisi kanan dari persamaan diferensial urutan pertama \\(y' = f(y,t)\\) . t adalah array 1D NumPy dari nilai \\(t\\) di mana kita mendekati nilai \\(y\\) . y0 adalah nilai awal \\(y(t_0)=y_0\\) di mana \\(t_0\\) adalah entri pada indeks 0 dari array t. Fungsi odeEuler mengembalikan array 1D NumPy dari nilai \\(y\\) yang memperkirakan solusi \\(y(t)\\) dari persamaan diferensial \\[ y' = f(y,t) \\ , \\ \\ y(t_0)=y_0 \\] dengan metode Euler. Perhatikan bahwa kita tidak menentukan nilai langkah waktu \\(h\\) Sebagai gantinya, fungsi odeEuler mengambil array nilai \\(t\\) dan mengembalikan nilai \\(y\\) yang mendekati solusi \\(y(t)\\) dengan rumus \\[ y_{n+1} = y_n + f(y_n,t_n)(t_{n+1} - t_n) \\] def odeEuler(f,y0,t): '''Perkiraan solusi y'=f(y,t) dengan metode Euler. Parameters ---------- f : function Sisi kanan persamaan diferensial y'=f(t,y), y(t_0)=y_0 y0 : number Nilai awal y(t0)=y0 di mana t0 adalah entri pada indeks 0 dalam array t t : array Array 1D NumPy dari nilai t di mana kita memperkirakan nilai y. Langkah waktu pada setiap iterasi diberikan oleh t[n+1] - t[n]. Returns ------- y : 1D NumPy array Perkiraan y[n] solusi y(t_n) dihitung dengan metode Euler. ''' y = np.zeros(len(t)) y[0] = y0 for n in range(0,len(t)-1): y[n+1] = y[n] + f(y[n],t[n])*(t[n+1] - t[n]) return y Contoh Persamaan Eksponensial Mari kita terapkan metode Euler untuk solusi perkiraan \\(y' = y\\) untuk \\(t \\in [0,2]\\) . Kita tahu solusinya adalah \\(y(t) = e^t\\) dalam hal ini dan sehingga kita dapat membandingkan perkiraan dengan metode Euler dengan solusi yang benar. t = np.linspace(0,2,21) y0 = 1 f = lambda y,t: y y = odeEuler(f,y0,t) y_true = np.exp(t) plt.plot(t,y,'b.-',t,y_true,'r-') plt.legend(['Euler','True']) plt.axis([0,2,0,9]) plt.grid(True) plt.title(\"Solution of $y'=y , y(0)=1$\") plt.show() Persamaan Non-linear Mari kita plot perkiraan \\(y'=y^2\\) untuk \\(y(0)=-1\\) . Kita tahu solusinya adalah \\[ y(t) = \\frac{-1}{t+1} \\] t = np.linspace(0,5,16) y0 = -1 f = lambda y,t: y**2 y = odeEuler(f,y0,t) t_true = np.linspace(0,5,100) y_true = -1/(t_true + 1) plt.plot(t,y,'r.-',t_true,y_true) plt.legend(['Euler','True']) plt.grid(True) plt.axis([0,5,-1,0]) plt.title(\"Solution of $y'=y^2 , y(0)=1$\") plt.show() Persamaan Otonom Mari kita lakukan sebuah contoh di mana kita tahu bahwa tidak mungkin untuk menemukan solusi yang sebenarnya. Mari kita perkiraan solusi \\(y' = \\sin(y^2)\\) untuk setiap kondisi awal \\(y(0)=-3,-2.75,-2.5,...,2.5,2.75\\) dan plot semua hasil bersama-sama. Perhatikan bahwa \\(y'=0\\) ketika \\(y=\\pm \\sqrt{k \\pi}\\) untuk \\(k=0,1,2,3,4,...\\) . Poin-poin ini disebut titik keseimbangan persamaan dan mewakili solusi status stabil (atau konstanta). t0 = 0; tf = 3; h = 0.1; f = lambda y,t: np.sin(y**2) t = np.arange(t0,tf+h,h) for y0 in np.arange(-3,3,0.25): y = odeEuler(f,y0,t) plt.plot(t,y,'b') for k in range(0,3): y_eq = np.sqrt(k*np.pi) plt.plot([t0,tf],[y_eq,y_eq],'r--') plt.plot([t0,tf],[-y_eq,-y_eq],'r--') plt.grid(True) plt.axis([0,3,-3,3.5]) plt.title(\"Equilibrium solutions of $y'=\\sin(y^2)$\") plt.show()","title":"Persamaan Urutan Pertama"},{"location":"Persamaan%20Diferensial/02_Persamaan%20Urutan%20Pertama/#persamaan-urutan-pertama","text":"Disini kita akan menggunakan numpy dan matplotlib, maka sebelum kita mulai, mari kita import kedua package tersebut: import numpy as np import matplotlib.pyplot as plt","title":"Persamaan Urutan Pertama"},{"location":"Persamaan%20Diferensial/02_Persamaan%20Urutan%20Pertama/#definisi","text":"Persamaan diferensial adalah persamaan yang melibatkan fungsi \\(y(t)\\) yang tidak diketahui (dengan variabel independen \\(t\\) ) dan turunannya \\(y'\\) , \\(y''\\) , \\(y'''\\) , dll. Urutan persamaan diferensial mengacu pada turunan urutan tertinggi dari fungsi \\(y(t)\\) yang tidak diketahui muncul dalam persamaan. Persamaan diferensial berjajar jika bentuknya \\[ a_n(t) y^{(n)} + a_{n_1}(t) y^{(n-1)} + \\cdots + a_1(t) y' + a_0(t) y_0 = f(t) \\] di mana \\(a_n, \\dots, a_0, f\\) adalah fungsi dari variabel independen \\(t\\) saja. Misalnya, persamaan \\[ y'' + ty' + y^2 = t \\] adalah urutan kedua non-linear, dan persamaan \\[ y' + ty = t^2 \\] adalah linear urutan pertama. Sebagian besar persamaan diferensial tidak mungkin dipecahkan secara eksplisit namun kita selalu dapat menggunakan metode numerik untuk solusi perkiraan.","title":"Definisi"},{"location":"Persamaan%20Diferensial/02_Persamaan%20Urutan%20Pertama/#metode-euler","text":"Metode numerik paling sederhana untuk mendekati solusi persamaan diferensial adalah metode Euler. Pertimbangkan persamaan diferensial urutan pertama dengan kondisi awal: \\[ y' = f(y,y) \\ , \\ \\ y(t_0)=y_0 \\] Prosedur untuk metode Euler adalah sebagai berikut: Buat persamaan garis tangen ke fungsi \\(y(t)\\) yang tidak diketahui di \\(t=t_0\\) : \\[ y = y(t_0) + f(y_0,t_0)(t - t_0) \\] di mana \\(y'(t_0) = f(y_0,t_0)\\) adalah kemiringan \\(y(t)\\) di \\(t=t_0\\) . Gunakan garis tangen untuk memperkirakan \\(y(t)\\) pada langkah kecil \\(t_1 = t_0 + h\\) . \\[ y_1 = y_0 + f(y_0,t_0)(t_1 - t_0) \\] di mana \\(y_1 \\approx y(t_1)\\) . Bangun garis tangen pada titik \\((t_1,y_1)\\) dan ulangi. Rumus untuk metode Euler menentukan urutan rekursif: \\[ y_{n+1} = y_n + f(y_n,t_n)(t_{n+1} - t_n) \\ , \\ \\ y_0 = y(t_0) \\] di mana \\(y_n \\approx y(t_n)\\) untuk setiap \\(n\\) . Jika kita memilih nilai \\(t\\) ber spasi yang sama maka rumus menjadi \\[ y_{n+1} = y_n + f(y_n,t_n)h \\ \\ , \\ \\ y_0 = y(t_0) \\ , \\ \\ t_n = t_0 + nh \\] dengan langkah waktu \\(h = t_{n+1} - t_n\\) . Perhatikan dua hal yang sangat penting tentang metode Euler dan metode numerik secara umum: Langkah waktu yang lebih kecil \\(h\\) mengurangi kesalahan dalam perkiraan. Langkah waktu yang lebih kecil \\(h\\) membutuhkan lebih banyak komputasi.","title":"Metode Euler"},{"location":"Persamaan%20Diferensial/02_Persamaan%20Urutan%20Pertama/#implementasi","text":"Mari kita tulis fungsi yang disebut odeEuler yang mengambil 3 parameter input f, y0, dan t di mana: f adalah fungsi dari 2 variabel yang mewakili sisi kanan dari persamaan diferensial urutan pertama \\(y' = f(y,t)\\) . t adalah array 1D NumPy dari nilai \\(t\\) di mana kita mendekati nilai \\(y\\) . y0 adalah nilai awal \\(y(t_0)=y_0\\) di mana \\(t_0\\) adalah entri pada indeks 0 dari array t. Fungsi odeEuler mengembalikan array 1D NumPy dari nilai \\(y\\) yang memperkirakan solusi \\(y(t)\\) dari persamaan diferensial \\[ y' = f(y,t) \\ , \\ \\ y(t_0)=y_0 \\] dengan metode Euler. Perhatikan bahwa kita tidak menentukan nilai langkah waktu \\(h\\) Sebagai gantinya, fungsi odeEuler mengambil array nilai \\(t\\) dan mengembalikan nilai \\(y\\) yang mendekati solusi \\(y(t)\\) dengan rumus \\[ y_{n+1} = y_n + f(y_n,t_n)(t_{n+1} - t_n) \\] def odeEuler(f,y0,t): '''Perkiraan solusi y'=f(y,t) dengan metode Euler. Parameters ---------- f : function Sisi kanan persamaan diferensial y'=f(t,y), y(t_0)=y_0 y0 : number Nilai awal y(t0)=y0 di mana t0 adalah entri pada indeks 0 dalam array t t : array Array 1D NumPy dari nilai t di mana kita memperkirakan nilai y. Langkah waktu pada setiap iterasi diberikan oleh t[n+1] - t[n]. Returns ------- y : 1D NumPy array Perkiraan y[n] solusi y(t_n) dihitung dengan metode Euler. ''' y = np.zeros(len(t)) y[0] = y0 for n in range(0,len(t)-1): y[n+1] = y[n] + f(y[n],t[n])*(t[n+1] - t[n]) return y","title":"Implementasi"},{"location":"Persamaan%20Diferensial/02_Persamaan%20Urutan%20Pertama/#contoh","text":"","title":"Contoh"},{"location":"Persamaan%20Diferensial/02_Persamaan%20Urutan%20Pertama/#persamaan-eksponensial","text":"Mari kita terapkan metode Euler untuk solusi perkiraan \\(y' = y\\) untuk \\(t \\in [0,2]\\) . Kita tahu solusinya adalah \\(y(t) = e^t\\) dalam hal ini dan sehingga kita dapat membandingkan perkiraan dengan metode Euler dengan solusi yang benar. t = np.linspace(0,2,21) y0 = 1 f = lambda y,t: y y = odeEuler(f,y0,t) y_true = np.exp(t) plt.plot(t,y,'b.-',t,y_true,'r-') plt.legend(['Euler','True']) plt.axis([0,2,0,9]) plt.grid(True) plt.title(\"Solution of $y'=y , y(0)=1$\") plt.show()","title":"Persamaan Eksponensial"},{"location":"Persamaan%20Diferensial/02_Persamaan%20Urutan%20Pertama/#persamaan-non-linear","text":"Mari kita plot perkiraan \\(y'=y^2\\) untuk \\(y(0)=-1\\) . Kita tahu solusinya adalah \\[ y(t) = \\frac{-1}{t+1} \\] t = np.linspace(0,5,16) y0 = -1 f = lambda y,t: y**2 y = odeEuler(f,y0,t) t_true = np.linspace(0,5,100) y_true = -1/(t_true + 1) plt.plot(t,y,'r.-',t_true,y_true) plt.legend(['Euler','True']) plt.grid(True) plt.axis([0,5,-1,0]) plt.title(\"Solution of $y'=y^2 , y(0)=1$\") plt.show()","title":"Persamaan Non-linear"},{"location":"Persamaan%20Diferensial/02_Persamaan%20Urutan%20Pertama/#persamaan-otonom","text":"Mari kita lakukan sebuah contoh di mana kita tahu bahwa tidak mungkin untuk menemukan solusi yang sebenarnya. Mari kita perkiraan solusi \\(y' = \\sin(y^2)\\) untuk setiap kondisi awal \\(y(0)=-3,-2.75,-2.5,...,2.5,2.75\\) dan plot semua hasil bersama-sama. Perhatikan bahwa \\(y'=0\\) ketika \\(y=\\pm \\sqrt{k \\pi}\\) untuk \\(k=0,1,2,3,4,...\\) . Poin-poin ini disebut titik keseimbangan persamaan dan mewakili solusi status stabil (atau konstanta). t0 = 0; tf = 3; h = 0.1; f = lambda y,t: np.sin(y**2) t = np.arange(t0,tf+h,h) for y0 in np.arange(-3,3,0.25): y = odeEuler(f,y0,t) plt.plot(t,y,'b') for k in range(0,3): y_eq = np.sqrt(k*np.pi) plt.plot([t0,tf],[y_eq,y_eq],'r--') plt.plot([t0,tf],[-y_eq,-y_eq],'r--') plt.grid(True) plt.axis([0,3,-3,3.5]) plt.title(\"Equilibrium solutions of $y'=\\sin(y^2)$\") plt.show()","title":"Persamaan Otonom"}]}